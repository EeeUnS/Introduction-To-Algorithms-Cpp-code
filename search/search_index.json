{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction To Algorithms This is Cpp code from pseudocode in CLRS see repository this I Foundations & II Sorting and Order Statistics Ch 2,4,6,7,8 Sort Ch 4 Divide-and-Conquer Ch 9 [Medians and Order Statistics III Data Structures CH 10 Data Structures Ch 12 [Binary Search Trees CH 11 Hash Tables Ch 13 [Red-Black Trees \ubbf8\uc644 \uc791\ub3d9x IV Advanced Design and Analysis Techniques Ch 15 [Dynamic Programming Ch 16 [Greedy Algorithms \ubbf8\uc644 V Advanced Data Structures Ch 18 B-Trees Ch 19 Fibonacci Heaps Ch 20 van Emde Boas Trees Ch 21 [Data Structures for Disjoint Sets VI Graph Algorithms(22~26) Ch 22.1~3 [BFS,DFS Ch 22.4 [Topological Sort Ch 22.5 [Strongly connected component Ch 23 [Minimum Spaning Tree Ch 24 [Single Source Shortest Paths Ch 25 [All-Pairs Shortest Paths VII Selected Topics Ch 27 [Multithreaded Algorithms \ubbf8\uc644 \uc791\ub3d9x Ch 28 [Matrix Operations 29 Linear Programming Ch 30 [Polynomials and the FFT \ubbf8\uc644 Ch 31 [Number-Theoretic Algorithms Ch 32 [String Matching Ch 33 Computational Geometry Ch 35 Approximation Algorithms Tex \uac1c\uc778\uc801\uc73c\ub85c \ucc45 \ub0b4\uc6a9\uc774 \ub108\ubb34 \uc5b4\ub824\uc6cc \uc774\ud574\ud558\uae30\uac00 \uc5b4\ub824\uc6e0\ub358 \ubd80\ubd84\uc744 \ub2e4\uc2dc \uc774\ud574\ud558\uae30 \uc27d\uac8c \ub9cc\ub4e0 pdf\ud30c\uc77c\ub4e4\uc785\ub2c8\ub2e4. goto repository quick sort number theory string matching string matching ppt FFT Test code & header file goto repository","title":"Preface"},{"location":"#introduction-to-algorithms","text":"This is Cpp code from pseudocode in CLRS see repository this","title":"Introduction To Algorithms"},{"location":"#i-foundations-ii-sorting-and-order-statistics","text":"Ch 2,4,6,7,8 Sort Ch 4 Divide-and-Conquer Ch 9 [Medians and Order Statistics","title":"I Foundations &amp; II Sorting and Order Statistics"},{"location":"#iii-data-structures","text":"CH 10 Data Structures Ch 12 [Binary Search Trees CH 11 Hash Tables Ch 13 [Red-Black Trees \ubbf8\uc644 \uc791\ub3d9x","title":"III Data Structures"},{"location":"#iv-advanced-design-and-analysis-techniques","text":"Ch 15 [Dynamic Programming Ch 16 [Greedy Algorithms \ubbf8\uc644","title":"IV Advanced Design and Analysis Techniques"},{"location":"#v-advanced-data-structures","text":"Ch 18 B-Trees Ch 19 Fibonacci Heaps Ch 20 van Emde Boas Trees Ch 21 [Data Structures for Disjoint Sets","title":"V Advanced Data Structures"},{"location":"#vi-graph-algorithms2226","text":"Ch 22.1~3 [BFS,DFS Ch 22.4 [Topological Sort Ch 22.5 [Strongly connected component Ch 23 [Minimum Spaning Tree Ch 24 [Single Source Shortest Paths Ch 25 [All-Pairs Shortest Paths","title":"VI Graph Algorithms(22~26)"},{"location":"#vii-selected-topics","text":"Ch 27 [Multithreaded Algorithms \ubbf8\uc644 \uc791\ub3d9x Ch 28 [Matrix Operations 29 Linear Programming Ch 30 [Polynomials and the FFT \ubbf8\uc644 Ch 31 [Number-Theoretic Algorithms Ch 32 [String Matching Ch 33 Computational Geometry Ch 35 Approximation Algorithms","title":"VII Selected Topics"},{"location":"#tex","text":"\uac1c\uc778\uc801\uc73c\ub85c \ucc45 \ub0b4\uc6a9\uc774 \ub108\ubb34 \uc5b4\ub824\uc6cc \uc774\ud574\ud558\uae30\uac00 \uc5b4\ub824\uc6e0\ub358 \ubd80\ubd84\uc744 \ub2e4\uc2dc \uc774\ud574\ud558\uae30 \uc27d\uac8c \ub9cc\ub4e0 pdf\ud30c\uc77c\ub4e4\uc785\ub2c8\ub2e4. goto repository quick sort number theory string matching string matching ppt FFT","title":"Tex"},{"location":"#test-code-header-file","text":"goto repository","title":"Test code &amp; header file"},{"location":"Graph/22_1_2_3/","text":"22.1 Representations of graphs An adjacency-list representation of G. 1 typedef std :: vector < std :: vector < int >> Graph ; Graph\ub294 \uc778\uc811 \ub9ac\uc2a4\ud2b8\ub85c \ud45c\ud604 22.2Breath first search $O(V+E)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void BFS ( const Graph & G , int x ) { std :: queue < int > Q ; Q . push ( x ); std :: vector < bool > visit ( G . size (), false ); visit [ x ] = true ; while ( ! Q . empty ()) { int here = Q . front (); Q . pop (); std :: cout << here << ' ' ; // \uc21c\ud68c \ucd9c\ub825 for ( int next : G [ here ]) { if ( visit [ next ] != true ) { visit [ next ] = true ; Q . push ( next ); } } } } 1 2 void PRINT_PATH ( int s , int v ) // go to testcode PRINT_PATH.cpp 22.3 Depth first search $\\Theta(V + E)$ with recursion V.color changed visit array 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void DFS ( const Graph & G , int s ) { std :: vector < bool > visit ( G . size (), false ); DFS_VISIT ( G , s , visit ); } void DFS_VISIT ( const Graph & G , int x , std :: vector < bool > & visit ) { visit [ x ] = true ; std :: cout << x << ' ' ; // \uc21c\ud68c\ucd9c\ub825 for ( int next : G [ x ]) { if ( visit [ next ] != true ) DFS_VISIT ( G , next , visit ); } } with stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void DFS ( const Graph & G , int x ) { std :: vector < bool > visit ( G . size (), false ); visit [ x ] = true ; std :: stack < int > sub_s ; sub_s . push ( x ); //std::cout << sub_s.top() << ' '; // \uc21c\ud68c\ucd9c\ub825 while ( ! sub_s . empty ()) { int y = sub_s . top (); for ( int next : G [ y ]) { if ( visit [ next ] != true ) { visit [ next ] = true ; sub_s . push ( next ); //std::cout << sub_s.top() << ' '; // \uc21c\ud68c\ucd9c\ub825 i = - 1 ; y = sub_s . top (); G_size = G [ y ]. size (); } } sub_s . pop (); } }","title":"22 1 2 3"},{"location":"Graph/22_1_2_3/#221-representations-of-graphs","text":"An adjacency-list representation of G. 1 typedef std :: vector < std :: vector < int >> Graph ; Graph\ub294 \uc778\uc811 \ub9ac\uc2a4\ud2b8\ub85c \ud45c\ud604","title":"22.1 Representations of graphs"},{"location":"Graph/22_1_2_3/#222breath-first-search","text":"$O(V+E)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void BFS ( const Graph & G , int x ) { std :: queue < int > Q ; Q . push ( x ); std :: vector < bool > visit ( G . size (), false ); visit [ x ] = true ; while ( ! Q . empty ()) { int here = Q . front (); Q . pop (); std :: cout << here << ' ' ; // \uc21c\ud68c \ucd9c\ub825 for ( int next : G [ here ]) { if ( visit [ next ] != true ) { visit [ next ] = true ; Q . push ( next ); } } } } 1 2 void PRINT_PATH ( int s , int v ) // go to testcode PRINT_PATH.cpp","title":"22.2Breath first search"},{"location":"Graph/22_1_2_3/#223-depth-first-search","text":"$\\Theta(V + E)$ with recursion V.color changed visit array 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void DFS ( const Graph & G , int s ) { std :: vector < bool > visit ( G . size (), false ); DFS_VISIT ( G , s , visit ); } void DFS_VISIT ( const Graph & G , int x , std :: vector < bool > & visit ) { visit [ x ] = true ; std :: cout << x << ' ' ; // \uc21c\ud68c\ucd9c\ub825 for ( int next : G [ x ]) { if ( visit [ next ] != true ) DFS_VISIT ( G , next , visit ); } } with stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void DFS ( const Graph & G , int x ) { std :: vector < bool > visit ( G . size (), false ); visit [ x ] = true ; std :: stack < int > sub_s ; sub_s . push ( x ); //std::cout << sub_s.top() << ' '; // \uc21c\ud68c\ucd9c\ub825 while ( ! sub_s . empty ()) { int y = sub_s . top (); for ( int next : G [ y ]) { if ( visit [ next ] != true ) { visit [ next ] = true ; sub_s . push ( next ); //std::cout << sub_s.top() << ' '; // \uc21c\ud68c\ucd9c\ub825 i = - 1 ; y = sub_s . top (); G_size = G [ y ]. size (); } } sub_s . pop (); } }","title":"22.3 Depth first search"},{"location":"Graph/22_4_DAG/","text":"22.4 Topological Sort Directed acyclic graph https://www.acmicpc.net/problem/2252 \ucc45\uc548\uc758 \uad6c\uc870 DFS \uc0ac\uc6a9 Cormen et al. (2001); Tarjan (1976)\uc774 \uc81c\uc548 1 2 3 4 5 6 7 8 9 10 11 12 13 14 std :: stack < int > topologicalsort ( const Graph & G ) { const int n = G . size (); std :: vector < bool > visit ( n , false ); stack < int > S ; // \uc2e4\uc81c \uc815\ub82c\ub41c\uac12\uc774 \uc5ed\uc21c\uc73c\ub85c \ub4e4\uc5b4\uac00\uc788\ub2e4. for ( std :: size_t i = 1 ; i < n ; i ++ ) { if ( visit [ i ] != true ) { DFS_TS ( G , visit , S , i ); } } return S ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 //recursion void DFS_TS ( const Graph & G , std :: vector < bool >& visit , stack < int >& S , int x ) { visit [ x ] = true ; //std::cout << x << ' '; // \uc21c\ud68c\ucd9c\ub825 for ( int next : G [ x ]) { if ( visit [ next ] != true ) { DFS_TS ( G , visit , S , next ); } } S . push ( x ); } //for with stack void DFS_TS ( Graph & G , std :: vector < bool >& visit , stack < int >& S , int x ) { visit [ x ] = true ; std :: stack < int > sub_s ; sub_s . push ( x ); //std::cout << sub_s.top() << ' '; // \uc21c\ud68c\ucd9c\ub825 while ( ! sub_s . empty ()) { int y = sub_s . top (); for ( std :: size_t i = 0 ; i < G [ y ]. size (); i ++ ) { int next = G [ y ][ i ]; if ( visit [ next ] != true ) { visit [ next ] = true ; sub_s . push ( next ); //std::cout << sub_s.top() << ' '; // \uc21c\ud68c\ucd9c\ub825 i = - 1 ; y = sub_s . top (); } } S . push ( sub_s . top ()); sub_s . pop (); } } \ud568\uc218 \uc2a4\ud0dd\uc774 \uac00\uc7a5 \ube60\ub974\ub2e4. \uae30\uc874 DFS\uc640 \ucc28\uc774\ub294 \ub9c8\uc9c0\ub9c9 sub_s.pop()\ud558\uae30\uc804\uc5d0 \uac12\uc744 S\uc5d0 \ub123\ub294 \uac83\uc774\ub2e4. \ud574\ub2f9 \uc54c\uace0\ub9ac\uc998\uc758 \uac1c\uc120\uc740 \ub2e4\uc74c\uc758 \ucf54\ub4dc\ub4e4\uc744 \ucc38\uace0. https://www.acmicpc.net/source/14181460 https://www.acmicpc.net/source/14181554 https://www.acmicpc.net/source/14181784 \uc7ac\uadc0 https://www.acmicpc.net/source/14192056 \ubc18\ubcf5 https://www.acmicpc.net/source/14193108 Kahn's algorithm \ucc38\uace0 : https://blog.naver.com/PostView.nhn?blogId=ndb796&logNo=221236874984&proxyReferer=https%3A%2F%2Fwww.google.com%2F https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 std :: vector < int > topologicalsort ( const Graph & G , int v ) { std :: vector < int > indegree ( v + 1 ); std :: queue < int > qu ; std :: vector < int > DAG ; for ( int i = 1 ; i <= v ; i ++ ) { for ( int j : G [ i ]) { indegree [ j ] ++ ; } } for ( int i = 1 ; i <= v ; i ++ ) { if ( indegree [ i ] == 0 ) { qu . push ( i ); } } for ( int i = 1 ; i <= v ; i ++ ) { if ( qu . empty ()) { return DAG ; } int x = qu . front (); qu . pop (); DAG . push_back ( x ); for ( int y : G [ x ]) { indegree [ y ] -- ; if ( indegree [ y ] == 0 ) { qu . push ( y ); } } } return DAG ; }","title":"22.4 Topological sort"},{"location":"Graph/22_4_DAG/#224-topological-sort","text":"","title":"22.4 Topological Sort"},{"location":"Graph/22_4_DAG/#directed-acyclic-graph","text":"https://www.acmicpc.net/problem/2252","title":"Directed acyclic graph"},{"location":"Graph/22_4_DAG/#_1","text":"DFS \uc0ac\uc6a9 Cormen et al. (2001); Tarjan (1976)\uc774 \uc81c\uc548 1 2 3 4 5 6 7 8 9 10 11 12 13 14 std :: stack < int > topologicalsort ( const Graph & G ) { const int n = G . size (); std :: vector < bool > visit ( n , false ); stack < int > S ; // \uc2e4\uc81c \uc815\ub82c\ub41c\uac12\uc774 \uc5ed\uc21c\uc73c\ub85c \ub4e4\uc5b4\uac00\uc788\ub2e4. for ( std :: size_t i = 1 ; i < n ; i ++ ) { if ( visit [ i ] != true ) { DFS_TS ( G , visit , S , i ); } } return S ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 //recursion void DFS_TS ( const Graph & G , std :: vector < bool >& visit , stack < int >& S , int x ) { visit [ x ] = true ; //std::cout << x << ' '; // \uc21c\ud68c\ucd9c\ub825 for ( int next : G [ x ]) { if ( visit [ next ] != true ) { DFS_TS ( G , visit , S , next ); } } S . push ( x ); } //for with stack void DFS_TS ( Graph & G , std :: vector < bool >& visit , stack < int >& S , int x ) { visit [ x ] = true ; std :: stack < int > sub_s ; sub_s . push ( x ); //std::cout << sub_s.top() << ' '; // \uc21c\ud68c\ucd9c\ub825 while ( ! sub_s . empty ()) { int y = sub_s . top (); for ( std :: size_t i = 0 ; i < G [ y ]. size (); i ++ ) { int next = G [ y ][ i ]; if ( visit [ next ] != true ) { visit [ next ] = true ; sub_s . push ( next ); //std::cout << sub_s.top() << ' '; // \uc21c\ud68c\ucd9c\ub825 i = - 1 ; y = sub_s . top (); } } S . push ( sub_s . top ()); sub_s . pop (); } } \ud568\uc218 \uc2a4\ud0dd\uc774 \uac00\uc7a5 \ube60\ub974\ub2e4. \uae30\uc874 DFS\uc640 \ucc28\uc774\ub294 \ub9c8\uc9c0\ub9c9 sub_s.pop()\ud558\uae30\uc804\uc5d0 \uac12\uc744 S\uc5d0 \ub123\ub294 \uac83\uc774\ub2e4. \ud574\ub2f9 \uc54c\uace0\ub9ac\uc998\uc758 \uac1c\uc120\uc740 \ub2e4\uc74c\uc758 \ucf54\ub4dc\ub4e4\uc744 \ucc38\uace0. https://www.acmicpc.net/source/14181460 https://www.acmicpc.net/source/14181554 https://www.acmicpc.net/source/14181784 \uc7ac\uadc0 https://www.acmicpc.net/source/14192056 \ubc18\ubcf5 https://www.acmicpc.net/source/14193108","title":"\ucc45\uc548\uc758 \uad6c\uc870"},{"location":"Graph/22_4_DAG/#kahns-algorithm","text":"\ucc38\uace0 : https://blog.naver.com/PostView.nhn?blogId=ndb796&logNo=221236874984&proxyReferer=https%3A%2F%2Fwww.google.com%2F https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 std :: vector < int > topologicalsort ( const Graph & G , int v ) { std :: vector < int > indegree ( v + 1 ); std :: queue < int > qu ; std :: vector < int > DAG ; for ( int i = 1 ; i <= v ; i ++ ) { for ( int j : G [ i ]) { indegree [ j ] ++ ; } } for ( int i = 1 ; i <= v ; i ++ ) { if ( indegree [ i ] == 0 ) { qu . push ( i ); } } for ( int i = 1 ; i <= v ; i ++ ) { if ( qu . empty ()) { return DAG ; } int x = qu . front (); qu . pop (); DAG . push_back ( x ); for ( int y : G [ x ]) { indegree [ y ] -- ; if ( indegree [ y ] == 0 ) { qu . push ( y ); } } } return DAG ; }","title":"Kahn's algorithm"},{"location":"Graph/22_5_SCC/","text":"22.5 Strongly connected component \ubb38\uc81c: https://www.acmicpc.net/problem/2150 Kosaraju's algorithm \uc2e4\uc81c \ucc45\uc5d0 \uc18c\uac1c\ub418\ub294 \uc54c\uace0\ub9ac\uc998 \ucc38\uace0 : https://jason9319.tistory.com/98 $O(V+E)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 Graph STRONGLY_CONNECTED_COMPONENTS ( const Graph & G ) { const int v = G . size () - 1 ; Graph SSC ; std :: stack < int > DFSf ; // DFS pop \uc21c\uc11c\ub300\ub85c \ub4e4\uc5b4\uac00\uc788\ub2e4. std :: vector < bool > visit ( v + 2 , false ); for ( int i = 1 ; i <= v ; i ++ ) { if ( visit [ i ] != true ) DFS ( G , i , DFSf , visit ); //DFS\uc21c\ud68c \uc21c\uc11c\ub97c S\uc5d0 \uc800\uc7a5\ud55c\ub2e4. } Graph TG ( v + 1 , ( std :: vector < int > ())); //G^T for ( int i = 1 ; i <= v ; i ++ ) { for ( int j : G [ i ]) { TG [ j ]. push_back ( i ); } } visit . assign ( v + 1 , false ); for ( int i = 0 ; i < v ; i ++ ) { if ( visit [ DFSf . top ()] != true ) { SSC . push_back ( std :: vector < int > ()); TDFS ( TG , DFSf . top (), SSC [ SSC . size () - 1 ], visit ); ///SSC_n++; } DFSf . pop (); } return SSC ; } with for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void DFS ( const Graph & G , int x , std :: stack < int >& DFSf , std :: vector < bool > & visit ) { visit [ x ] = true ; std :: stack < int > sub_s ; sub_s . push ( x ); while ( ! sub_s . empty ()) { int y = sub_s . top (); for ( std :: size_t i = 0 ; i < G [ y ]. size (); i ++ ) { int next = G [ y ][ i ]; if ( visit [ next ] != true ) { visit [ next ] = true ; sub_s . push ( next ); i = - 1 ; y = sub_s . top (); } } DFSf . push ( sub_s . top ()); //\uae30\uc874 DFS\uc640 \ucc28\uc774 STACK\uc5d0 \uc885\ub8cc \uc21c\uc11c \uc800\uc7a5 sub_s . pop (); } } with recursion 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void DFS ( const Graph & G , int x , std :: stack < int >& DFSf , std :: vector < bool >& visit ) { visit [ x ] = true ; //std::cout << x << ' '; // \uc21c\ud68c\ucd9c\ub825 for ( int next : G [ x ]) { if ( visit [ next ] != true ) { DFS ( G , next , DFSf , visit ); } } DFSf . push ( x ); //\uae30\uc874 DFS\uc640 \ucc28\uc774 STACK\uc5d0 \uc885\ub8cc \uc21c\uc11c \uc800\uc7a5 } with for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void TDFS ( Graph & TG , int x , std :: vector < int > & SSC , std :: vector < bool > & visit ) //G^T\ud0d0\uc0c9 { visit [ x ] = true ; std :: stack < int > sub_s ; sub_s . push ( x ); //std::cout << sub_s.top() << ' '; // \uc21c\ud68c\ucd9c\ub825 while ( ! sub_s . empty ()) { int y = sub_s . top (); for ( std :: size_t i = 0 ; i < TG [ y ]. size (); i ++ ) { int next = TG [ y ][ i ]; if ( visit [ next ] != true ) { visit [ next ] = true ; sub_s . push ( next ); //std::cout << sub_s.top() << ' '; // \uc21c\ud68c\ucd9c\ub825 i = - 1 ; y = sub_s . top (); } } SSC . push_back ( sub_s . top ()); sub_s . pop (); } } with recursion 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //SSC[] 1D vector void TDFS ( Graph & TG , int x , std :: vector < int >& SSC , std :: vector < bool >& visit ) { visit [ x ] = true ; //std::cout << x << ' '; // \uc21c\ud68c\ucd9c\ub825 for ( int next : TG [ x ]) { if ( visit [ next ] != true ) { TDFS ( TG , next , SSC , visit ); } } SSC . push_back ( x ); } + Tarjan's alg $O(V+E)$ \ucc38\uace0 : https://blog.naver.com/PostView.nhn?blogId=ndb796&logNo=221236952158&parentCategoryNo=&categoryNo=128&viewDate=&isShowPopularPosts=false&from=postView \ud574\ub2f9 \ucf54\ub4dc\ub97c \ud1a0\ub300\ub85c \ub9e4\uac1c\ubcc0\uc218\ub97c \uc62e\uae40 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // \uc790\uc2e0\uc758 \uacb0\uacfc\uac12\uc744 \ub9ac\ud134\ud558\ub294 DFS \ud568\uc218 int DFS ( int curr , vector < vector < int >>& SCC , vector < bool >& finished , stack < int >& S , vector < vector < int >>& adj , vector < int >& dfsn , int & cnt ) { dfsn [ curr ] = ++ cnt ; // dfsn \uacb0\uc815 S . push ( curr ); // \uc2a4\ud0dd\uc5d0 \uc790\uc2e0\uc744 push // \uc790\uc2e0\uc758 dfsn, \uc790\uc2dd\ub4e4\uc758 \uacb0\uacfc\ub098 dfsn \uc911 \uac00\uc7a5 \uc791\uc740 \ubc88\ud638\ub97c result\uc5d0 \uc800\uc7a5 int result = dfsn [ curr ]; for ( int next : adj [ curr ]) { // \uc544\uc9c1 \ubc29\ubb38\ud558\uc9c0 \uc54a\uc740 \uc774\uc6c3 if ( dfsn [ next ] == 0 ) { result = min ( result , DFS ( next , SCC , finished , S , adj , dfsn , cnt )); } // \ubc29\ubb38\uc740 \ud588\uc73c\ub098 \uc544\uc9c1 SCC\ub85c \ucd94\ucd9c\ub418\uc9c0\ub294 \uc54a\uc740 \uc774\uc6c3 else if ( ! finished [ next ]) { result = min ( result , dfsn [ next ]); } } // \uc790\uc2e0, \uc790\uc2e0\uc758 \uc790\uc190\ub4e4\uc774 \ub3c4\ub2ec \uac00\ub2a5\ud55c \uc81c\uc77c \ub192\uc740 \uc815\uc810\uc774 \uc790\uc2e0\uc77c \uacbd\uc6b0 SCC \ucd94\ucd9c if ( result == dfsn [ curr ]) { vector < int > currSCC ; // \uc2a4\ud0dd\uc5d0\uc11c \uc790\uc2e0\uc774 \ub098\uc62c \ub54c\uae4c\uc9c0 pop while ( 1 ) { int t = S . top (); S . pop (); currSCC . push_back ( t ); finished [ t ] = true ; //sn[t] = SN; if ( t == curr ) { break ; } } // \ucd9c\ub825\uc744 \uc704\ud574 \uc6d0\uc18c \uc815\ub82c sort ( currSCC . begin (), currSCC . end ()); // SCC \ucd94\ucd9c SCC . push_back ( currSCC ); } return result ; } std :: vector < vector < int >> TARJAN_ALG ( std :: vector < vector < int >>& adj ) { const int V = adj . size (); std :: vector < int > dfsn ( V + 1 ); std :: vector < vector < int >> SCC ; std :: stack < int > S ; std :: vector < bool > finished ( V + 1 ); // SCC \ubd84\ub9ac\uac00 \ub05d\ub09c \uc815\uc810\ub9cc true int cnt = 0 ; for ( int i = 0 ; i < V - 1 ; i ++ ) { if ( dfsn [ i ] == 0 ) { DFS ( i , SCC , finished , S , adj , dfsn , cnt ); } } return SCC ; }","title":"22.5 Strongly connected components"},{"location":"Graph/22_5_SCC/#225-strongly-connected-component","text":"\ubb38\uc81c: https://www.acmicpc.net/problem/2150","title":"22.5 Strongly connected component"},{"location":"Graph/22_5_SCC/#kosarajus-algorithm","text":"\uc2e4\uc81c \ucc45\uc5d0 \uc18c\uac1c\ub418\ub294 \uc54c\uace0\ub9ac\uc998 \ucc38\uace0 : https://jason9319.tistory.com/98 $O(V+E)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 Graph STRONGLY_CONNECTED_COMPONENTS ( const Graph & G ) { const int v = G . size () - 1 ; Graph SSC ; std :: stack < int > DFSf ; // DFS pop \uc21c\uc11c\ub300\ub85c \ub4e4\uc5b4\uac00\uc788\ub2e4. std :: vector < bool > visit ( v + 2 , false ); for ( int i = 1 ; i <= v ; i ++ ) { if ( visit [ i ] != true ) DFS ( G , i , DFSf , visit ); //DFS\uc21c\ud68c \uc21c\uc11c\ub97c S\uc5d0 \uc800\uc7a5\ud55c\ub2e4. } Graph TG ( v + 1 , ( std :: vector < int > ())); //G^T for ( int i = 1 ; i <= v ; i ++ ) { for ( int j : G [ i ]) { TG [ j ]. push_back ( i ); } } visit . assign ( v + 1 , false ); for ( int i = 0 ; i < v ; i ++ ) { if ( visit [ DFSf . top ()] != true ) { SSC . push_back ( std :: vector < int > ()); TDFS ( TG , DFSf . top (), SSC [ SSC . size () - 1 ], visit ); ///SSC_n++; } DFSf . pop (); } return SSC ; } with for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void DFS ( const Graph & G , int x , std :: stack < int >& DFSf , std :: vector < bool > & visit ) { visit [ x ] = true ; std :: stack < int > sub_s ; sub_s . push ( x ); while ( ! sub_s . empty ()) { int y = sub_s . top (); for ( std :: size_t i = 0 ; i < G [ y ]. size (); i ++ ) { int next = G [ y ][ i ]; if ( visit [ next ] != true ) { visit [ next ] = true ; sub_s . push ( next ); i = - 1 ; y = sub_s . top (); } } DFSf . push ( sub_s . top ()); //\uae30\uc874 DFS\uc640 \ucc28\uc774 STACK\uc5d0 \uc885\ub8cc \uc21c\uc11c \uc800\uc7a5 sub_s . pop (); } } with recursion 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void DFS ( const Graph & G , int x , std :: stack < int >& DFSf , std :: vector < bool >& visit ) { visit [ x ] = true ; //std::cout << x << ' '; // \uc21c\ud68c\ucd9c\ub825 for ( int next : G [ x ]) { if ( visit [ next ] != true ) { DFS ( G , next , DFSf , visit ); } } DFSf . push ( x ); //\uae30\uc874 DFS\uc640 \ucc28\uc774 STACK\uc5d0 \uc885\ub8cc \uc21c\uc11c \uc800\uc7a5 } with for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void TDFS ( Graph & TG , int x , std :: vector < int > & SSC , std :: vector < bool > & visit ) //G^T\ud0d0\uc0c9 { visit [ x ] = true ; std :: stack < int > sub_s ; sub_s . push ( x ); //std::cout << sub_s.top() << ' '; // \uc21c\ud68c\ucd9c\ub825 while ( ! sub_s . empty ()) { int y = sub_s . top (); for ( std :: size_t i = 0 ; i < TG [ y ]. size (); i ++ ) { int next = TG [ y ][ i ]; if ( visit [ next ] != true ) { visit [ next ] = true ; sub_s . push ( next ); //std::cout << sub_s.top() << ' '; // \uc21c\ud68c\ucd9c\ub825 i = - 1 ; y = sub_s . top (); } } SSC . push_back ( sub_s . top ()); sub_s . pop (); } } with recursion 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //SSC[] 1D vector void TDFS ( Graph & TG , int x , std :: vector < int >& SSC , std :: vector < bool >& visit ) { visit [ x ] = true ; //std::cout << x << ' '; // \uc21c\ud68c\ucd9c\ub825 for ( int next : TG [ x ]) { if ( visit [ next ] != true ) { TDFS ( TG , next , SSC , visit ); } } SSC . push_back ( x ); }","title":"Kosaraju's algorithm"},{"location":"Graph/22_5_SCC/#tarjans-alg","text":"$O(V+E)$ \ucc38\uace0 : https://blog.naver.com/PostView.nhn?blogId=ndb796&logNo=221236952158&parentCategoryNo=&categoryNo=128&viewDate=&isShowPopularPosts=false&from=postView \ud574\ub2f9 \ucf54\ub4dc\ub97c \ud1a0\ub300\ub85c \ub9e4\uac1c\ubcc0\uc218\ub97c \uc62e\uae40 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // \uc790\uc2e0\uc758 \uacb0\uacfc\uac12\uc744 \ub9ac\ud134\ud558\ub294 DFS \ud568\uc218 int DFS ( int curr , vector < vector < int >>& SCC , vector < bool >& finished , stack < int >& S , vector < vector < int >>& adj , vector < int >& dfsn , int & cnt ) { dfsn [ curr ] = ++ cnt ; // dfsn \uacb0\uc815 S . push ( curr ); // \uc2a4\ud0dd\uc5d0 \uc790\uc2e0\uc744 push // \uc790\uc2e0\uc758 dfsn, \uc790\uc2dd\ub4e4\uc758 \uacb0\uacfc\ub098 dfsn \uc911 \uac00\uc7a5 \uc791\uc740 \ubc88\ud638\ub97c result\uc5d0 \uc800\uc7a5 int result = dfsn [ curr ]; for ( int next : adj [ curr ]) { // \uc544\uc9c1 \ubc29\ubb38\ud558\uc9c0 \uc54a\uc740 \uc774\uc6c3 if ( dfsn [ next ] == 0 ) { result = min ( result , DFS ( next , SCC , finished , S , adj , dfsn , cnt )); } // \ubc29\ubb38\uc740 \ud588\uc73c\ub098 \uc544\uc9c1 SCC\ub85c \ucd94\ucd9c\ub418\uc9c0\ub294 \uc54a\uc740 \uc774\uc6c3 else if ( ! finished [ next ]) { result = min ( result , dfsn [ next ]); } } // \uc790\uc2e0, \uc790\uc2e0\uc758 \uc790\uc190\ub4e4\uc774 \ub3c4\ub2ec \uac00\ub2a5\ud55c \uc81c\uc77c \ub192\uc740 \uc815\uc810\uc774 \uc790\uc2e0\uc77c \uacbd\uc6b0 SCC \ucd94\ucd9c if ( result == dfsn [ curr ]) { vector < int > currSCC ; // \uc2a4\ud0dd\uc5d0\uc11c \uc790\uc2e0\uc774 \ub098\uc62c \ub54c\uae4c\uc9c0 pop while ( 1 ) { int t = S . top (); S . pop (); currSCC . push_back ( t ); finished [ t ] = true ; //sn[t] = SN; if ( t == curr ) { break ; } } // \ucd9c\ub825\uc744 \uc704\ud574 \uc6d0\uc18c \uc815\ub82c sort ( currSCC . begin (), currSCC . end ()); // SCC \ucd94\ucd9c SCC . push_back ( currSCC ); } return result ; } std :: vector < vector < int >> TARJAN_ALG ( std :: vector < vector < int >>& adj ) { const int V = adj . size (); std :: vector < int > dfsn ( V + 1 ); std :: vector < vector < int >> SCC ; std :: stack < int > S ; std :: vector < bool > finished ( V + 1 ); // SCC \ubd84\ub9ac\uac00 \ub05d\ub09c \uc815\uc810\ub9cc true int cnt = 0 ; for ( int i = 0 ; i < V - 1 ; i ++ ) { if ( dfsn [ i ] == 0 ) { DFS ( i , SCC , finished , S , adj , dfsn , cnt ); } } return SCC ; }","title":"+ Tarjan's alg"},{"location":"Graph/23_MST/","text":"23 Minimum Spaning Tree 1 2 typedef std :: vector < std :: vector < int >> Graph ; typedef std :: vector < std :: vector < std :: pair < int , int >>> Weight_Graph ; // [u] (v,w) 23.1 Growing a minimum spanning tree 23.2 The algorithms of Kruskal and Prim Kruskal's algorithm need Ch 21 class UNION_FOUND 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct edge { int u ; int v ; int w ; bool operator < ( edge & Edge ) { return this -> w < Edge . w ; } }; std :: vector < edge > MST_KRUSKAL ( const Graph & G , const std :: vector < edge >& W ) { std :: vector < edge > A ; const int n = G . size () - 1 ; UNION_FIND SET ( n + 1 ); for ( int v = 1 ; v <= n ; v ++ ) { SET . MAKE_SET ( v ); } std :: sort ( W . begin (), W . end ()); const int m = W . size (); for ( int i = 0 ; i < m ; i ++ ) { if ( SET . FIND_SET ( W [ i ]. u ) != SET . FIND_SET ( W [ i ]. v )) { A . push_back ({ W [ i ]. u , W [ i ]. v , W [ i ]. w }); SET . UNION ( W [ i ]. u , W [ i ]. v ); } } return A ; } Prim's algorithm 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 Set MST_PRIM ( const & Graph , int r ) { std :: priority_queue < std :: pair < int , int > , std :: vector < std :: pair < int , int >> , std :: greater < std :: pair < int , int >> > PQ ; std :: size_t vertex_n = Graph . size (); std :: vector < int > pi ( vertex_n , 0 ); // \uc815\uc810\uc758 \uc9c1\uc804 \uc6d0\uc18c \uc800\uc7a5 std :: vector < int > key ( vertex_n , INF ); // \uc815\uc810\uc758 \uc9c1\uc804 \uc6d0\uc18c\uc640\uc758 \uac04\uc120 \uac00\uc911\uce58 std :: vector < bool > visited ( vertex_n , false ); key [ r ] = 0 ; visited [ r ] = true ; const size_t r_size = Graph [ r ]. size (); for ( std :: size_t i = 0 ; i < r_size ; i ++ ) { int v = Graph [ r ][ i ]. first ; int w_uv = Graph [ r ][ i ]. second ; pi [ v ] = r ; key [ v ] = w_uv ; PQ . push ( std :: make_pair ( w_uv , v )); } while ( ! PQ . empty ()) { int u = PQ . top (). second ; int _key = PQ . top (). first ; PQ . pop (); if ( visited [ u ]) { continue ; } visited [ u ] = true ; size_t u_size = Graph [ u ]. size (); for ( size_t i = 0 ; i < u_size ; i ++ ) { int v = Graph [ u ][ i ]. first ; int w_uv = Graph [ u ][ i ]. second ; if ( ! visited [ v ] && w_uv < key [ v ]) { pi [ v ] = u ; key [ v ] = w_uv ; PQ . push ( std :: make_pair ( w_uv , v )); } } } return std :: make_pair ( pi , key ); }","title":"23 Minimum Spanning Trees"},{"location":"Graph/23_MST/#23-minimum-spaning-tree","text":"1 2 typedef std :: vector < std :: vector < int >> Graph ; typedef std :: vector < std :: vector < std :: pair < int , int >>> Weight_Graph ; // [u] (v,w)","title":"23 Minimum Spaning Tree"},{"location":"Graph/23_MST/#231-growing-a-minimum-spanning-tree","text":"","title":"23.1 Growing a minimum spanning tree"},{"location":"Graph/23_MST/#232-the-algorithms-of-kruskal-and-prim","text":"","title":"23.2 The algorithms of Kruskal and Prim"},{"location":"Graph/23_MST/#kruskals-algorithm","text":"need Ch 21 class UNION_FOUND 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct edge { int u ; int v ; int w ; bool operator < ( edge & Edge ) { return this -> w < Edge . w ; } }; std :: vector < edge > MST_KRUSKAL ( const Graph & G , const std :: vector < edge >& W ) { std :: vector < edge > A ; const int n = G . size () - 1 ; UNION_FIND SET ( n + 1 ); for ( int v = 1 ; v <= n ; v ++ ) { SET . MAKE_SET ( v ); } std :: sort ( W . begin (), W . end ()); const int m = W . size (); for ( int i = 0 ; i < m ; i ++ ) { if ( SET . FIND_SET ( W [ i ]. u ) != SET . FIND_SET ( W [ i ]. v )) { A . push_back ({ W [ i ]. u , W [ i ]. v , W [ i ]. w }); SET . UNION ( W [ i ]. u , W [ i ]. v ); } } return A ; }","title":"Kruskal's algorithm"},{"location":"Graph/23_MST/#prims-algorithm","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 Set MST_PRIM ( const & Graph , int r ) { std :: priority_queue < std :: pair < int , int > , std :: vector < std :: pair < int , int >> , std :: greater < std :: pair < int , int >> > PQ ; std :: size_t vertex_n = Graph . size (); std :: vector < int > pi ( vertex_n , 0 ); // \uc815\uc810\uc758 \uc9c1\uc804 \uc6d0\uc18c \uc800\uc7a5 std :: vector < int > key ( vertex_n , INF ); // \uc815\uc810\uc758 \uc9c1\uc804 \uc6d0\uc18c\uc640\uc758 \uac04\uc120 \uac00\uc911\uce58 std :: vector < bool > visited ( vertex_n , false ); key [ r ] = 0 ; visited [ r ] = true ; const size_t r_size = Graph [ r ]. size (); for ( std :: size_t i = 0 ; i < r_size ; i ++ ) { int v = Graph [ r ][ i ]. first ; int w_uv = Graph [ r ][ i ]. second ; pi [ v ] = r ; key [ v ] = w_uv ; PQ . push ( std :: make_pair ( w_uv , v )); } while ( ! PQ . empty ()) { int u = PQ . top (). second ; int _key = PQ . top (). first ; PQ . pop (); if ( visited [ u ]) { continue ; } visited [ u ] = true ; size_t u_size = Graph [ u ]. size (); for ( size_t i = 0 ; i < u_size ; i ++ ) { int v = Graph [ u ][ i ]. first ; int w_uv = Graph [ u ][ i ]. second ; if ( ! visited [ v ] && w_uv < key [ v ]) { pi [ v ] = u ; key [ v ] = w_uv ; PQ . push ( std :: make_pair ( w_uv , v )); } } } return std :: make_pair ( pi , key ); }","title":"Prim's algorithm"},{"location":"Graph/24_SSSP/","text":"Single Source Shortest Paths \uae30\ubcf8 \ud504\ub85c\uc2dc\uc800 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const int NIL = 0 ; const int INF = 100000000 ; int predecessor_subgraph [ MAX ]; //\uc9c1\uc804\uc6d0\uc18c \uadf8\ub798\ud504 v.pi void PRINT_PATH ( int s , int v ) { if ( v == s ) ; /*else if (predecessor_subgraph[v] == 0) //\ucd5c\ub2e8\uacbd\ub85c v\uac00 \ubcf4\uc7a5\ub418\uc5b4\uc788\uace0 start\uac00 0\uc77c\ub54c\ub294 \ud574\ub2f9 \uc8fc\uc11d\uc744 \ub5c0\ub2e4 { return; }*/ else PRINT_PATH ( s , predecessor_subgraph [ v ]); cout << v << ' ' ; } 2\ucc28 vector G s \uc815\uc810\uc73c\ub85c\ubd80\ud130 \ucd9c\ubc1c distance\ub294 \uc815\uc810 s\ub85c\ubd80\ud130\uc758 \uac70\ub9ac 1 2 3 4 5 6 7 8 9 void INITIALIZE_SINGLE_SOURCE ( const Graph & G , std :: vector < int >& Distance , int s ) { for ( std :: size_t i = 1 ; i < G . size (); i ++ ) { Distance [ i ] = INF ; } Distance [ s ] = 0 ; } \uc644\ud654\uc5d0\uc11c \ub2e4\uc74c \ud504\ub85c\uc2dc\uc800\ub97c \uc2e4\ud589\ud558\uace0 \ud558\uba74\ub41c\ub2e4. predecessor_subgraph[v] = u; 24.1 BELLMAN FORD u -> v : \uac00\uc911\uce58 w 1 2 3 4 5 6 7 8 void BF_RELAX ( int u , int v , int w , std :: vector < int >& Distance ) { if (( Distance [ u ] != INF ) && Distance [ v ] > Distance [ u ] + w ) { Distance [ v ] = Distance [ u ] + w ; //predecessor_subgraph[v] = u; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 bool BELLMAN_FORD ( const Graph & G , std :: vector < std :: vector < int >>& W , std :: vector < int > & Distance , int s ) { INITIALIZE_SINGLE_SOURCE ( G , Distance , s ); const std :: size_t n = G . size () - 1 ; for ( std :: size_t i = 1 ; i <= n ; i ++ ) // \uac04\uc120 u v w = G[v][] { for ( std :: size_t u = 0 ; u <= n ; u ++ ) { for ( int v : G [ u ]) { int w = W [ u ][ v ]; BF_RELAX ( u , v , w , Distance ); } } } for ( std :: size_t u = 1 ; u <= n ; u ++ ) { for ( int v : G [ u ]) { if (( Distance [ v ] > Distance [ u ] + W [ u ][ v ]) && Distance [ u ] != INF ) { Distance [ v ] = - 1 ; return false ; } } } return true ; } 24.2 Single-source shortest paths in directed acyclic graphs 1 2 3 4 5 6 7 8 9 W [ 1 ][ 2 ] = 5 ; W [ 2 ][ 3 ] = 2 ; W [ 2 ][ 4 ] = 6 ; W [ 3 ][ 4 ] = 7 ; W [ 3 ][ 5 ] = 4 ; W [ 3 ][ 6 ] = 2 ; W [ 4 ][ 5 ] = - 1 ; W [ 4 ][ 6 ] = 1 ; W [ 5 ][ 6 ] = - 2 ; $\\Theta(V+E)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 void DFS_TS ( const Graph & G , std :: vector < bool > & visit , stack < int > & S , int x ) { visit [ x ] = true ; //std::cout << x << ' '; // \uc21c\ud68c\ucd9c\ub825 for ( int next : G [ x ]) { if ( visit [ next ] != true ) { DFS_TS ( G , visit , S , next ); } } S . push ( x ); } std :: stack < int > topologicalsort ( const Graph & G ) { const int n = G . size (); std :: vector < bool > visit ; visit . resize ( n ); stack < int > S ; // \uc2e4\uc81c \uc815\ub82c\ub41c\uac12\uc774 \uc5ed\uc21c\uc73c\ub85c \ub4e4\uc5b4\uac00\uc788\ub2e4. for ( std :: size_t i = 1 ; i < n ; i ++ ) { if ( visit [ i ] != true ) { DFS_TS ( G , visit , S , i ); } } return S ; } void INITIALIZE_SINGLE_SOURCE ( const Graph & G , std :: vector < int >& Distance , int s ) { std :: fill ( Distance . begin (), Distance . begin () + Graph . size (), INF ); Distance [ s ] = 0 ; } void RELAX ( int u , int v , int w , std :: vector < int >& Distance ) { if ( Distance [ v ] > Distance [ u ] + w ) { Distance [ v ] = Distance [ u ] + w ; //predecessor_subgraph[v] = u; } } void DAG_SHORTEST_PATHS ( const Graph & G , std :: vector < std :: vector < int >>& W , std :: vector < int >& Distance , int s ) { std :: stack < int > S = topologicalsort ( G ); INITIALIZE_SINGLE_SOURCE ( G , Distance , s ); while ( ! S . empty ()) { int u = S . top (); S . pop (); for ( int v : G [ u ]) { RELAX ( u , v , W [ u ][ v ], Distance ); } } } 24.3 Dijkstra's algorithm \ucc38\uace0: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Running_time \uc6b0\uc120\uc21c\uc704\ud050 \uc0ac\uc6a9 $O(E\\log V)$ PQ\uc758 \ud0d1 \ub514\uc2a4\ud134\uc2a4\uac12\uc744 \uac31\uc2e0\uc2dc\ucf1c\uc57c\ud55c\ub2e4 \ub530\ub77c\uc11c \ubf51\uace0 \ub2e4\uc2dc\ub123\ub294\ub2e4. \ucc45\uc758 \uc758\uc0ac\ucf54\ub4dc\uc5d0 \uce58\uba85\uc801\uc778 \ubb38\uc81c\uac00 \ud558\ub098\uc788\ub294\ub370 \uc644\ud654\uc5d0\uc11c Q.decrease_priority\ub85c key \uac70\ub9ac\uac12\uc744 \uac31\uc2e0 \uc2dc\ucf1c\uc918\uc57c\ud55c\ub2e4. 1 2 3 4 5 6 7 8 9 10 11 12 13 void DIJK_RELAX ( int u , int v , int w , std :: vector < int >& Distance , std :: priority_queue < std :: pair < int , int > , std :: vector < std :: pair < int , int >> , std :: greater < std :: pair < int , int >>>& PQ ) { if (( Distance [ u ] != INF ) && ( Distance [ v ] > Distance [ u ] + w )) { Distance [ v ] = Distance [ u ] + w ; //predecessor_subgraph[v] = u; PQ . push ( std :: make_pair ( Distance [ v ], v )); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void DIJKSTRA ( const Graph & G , std :: vector < std :: vector < int >>& W , std :: vector < int > & Distance , int s ) { INITIALIZE_SINGLE_SOURCE ( G , Distance , s ); std :: priority_queue < std :: pair < int , int > , std :: vector < std :: pair < int , int >> , std :: greater < std :: pair < int , int >> > PQ ; //\uc815\uc810\uc758 \uac70\ub9ac, \uc815\uc810 for ( std :: size_t i = 1 ; i < G . size (); i ++ ) { PQ . push ( std :: make_pair ( Distance [ i ], i )); } while ( ! PQ . empty ()) { int u = PQ . top (). second ; PQ . pop (); for ( int v : G [ u ]) { DIJK_RELAX ( u , v , W [ u ][ v ], Distance , PQ ); } } }","title":"24 Single-Source Shortest Paths"},{"location":"Graph/24_SSSP/#single-source-shortest-paths","text":"\uae30\ubcf8 \ud504\ub85c\uc2dc\uc800 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const int NIL = 0 ; const int INF = 100000000 ; int predecessor_subgraph [ MAX ]; //\uc9c1\uc804\uc6d0\uc18c \uadf8\ub798\ud504 v.pi void PRINT_PATH ( int s , int v ) { if ( v == s ) ; /*else if (predecessor_subgraph[v] == 0) //\ucd5c\ub2e8\uacbd\ub85c v\uac00 \ubcf4\uc7a5\ub418\uc5b4\uc788\uace0 start\uac00 0\uc77c\ub54c\ub294 \ud574\ub2f9 \uc8fc\uc11d\uc744 \ub5c0\ub2e4 { return; }*/ else PRINT_PATH ( s , predecessor_subgraph [ v ]); cout << v << ' ' ; } 2\ucc28 vector G s \uc815\uc810\uc73c\ub85c\ubd80\ud130 \ucd9c\ubc1c distance\ub294 \uc815\uc810 s\ub85c\ubd80\ud130\uc758 \uac70\ub9ac 1 2 3 4 5 6 7 8 9 void INITIALIZE_SINGLE_SOURCE ( const Graph & G , std :: vector < int >& Distance , int s ) { for ( std :: size_t i = 1 ; i < G . size (); i ++ ) { Distance [ i ] = INF ; } Distance [ s ] = 0 ; } \uc644\ud654\uc5d0\uc11c \ub2e4\uc74c \ud504\ub85c\uc2dc\uc800\ub97c \uc2e4\ud589\ud558\uace0 \ud558\uba74\ub41c\ub2e4. predecessor_subgraph[v] = u;","title":"Single Source Shortest Paths"},{"location":"Graph/24_SSSP/#241-bellman-ford","text":"u -> v : \uac00\uc911\uce58 w 1 2 3 4 5 6 7 8 void BF_RELAX ( int u , int v , int w , std :: vector < int >& Distance ) { if (( Distance [ u ] != INF ) && Distance [ v ] > Distance [ u ] + w ) { Distance [ v ] = Distance [ u ] + w ; //predecessor_subgraph[v] = u; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 bool BELLMAN_FORD ( const Graph & G , std :: vector < std :: vector < int >>& W , std :: vector < int > & Distance , int s ) { INITIALIZE_SINGLE_SOURCE ( G , Distance , s ); const std :: size_t n = G . size () - 1 ; for ( std :: size_t i = 1 ; i <= n ; i ++ ) // \uac04\uc120 u v w = G[v][] { for ( std :: size_t u = 0 ; u <= n ; u ++ ) { for ( int v : G [ u ]) { int w = W [ u ][ v ]; BF_RELAX ( u , v , w , Distance ); } } } for ( std :: size_t u = 1 ; u <= n ; u ++ ) { for ( int v : G [ u ]) { if (( Distance [ v ] > Distance [ u ] + W [ u ][ v ]) && Distance [ u ] != INF ) { Distance [ v ] = - 1 ; return false ; } } } return true ; }","title":"24.1 BELLMAN FORD"},{"location":"Graph/24_SSSP/#242-single-source-shortest-paths-in-directed-acyclic-graphs","text":"1 2 3 4 5 6 7 8 9 W [ 1 ][ 2 ] = 5 ; W [ 2 ][ 3 ] = 2 ; W [ 2 ][ 4 ] = 6 ; W [ 3 ][ 4 ] = 7 ; W [ 3 ][ 5 ] = 4 ; W [ 3 ][ 6 ] = 2 ; W [ 4 ][ 5 ] = - 1 ; W [ 4 ][ 6 ] = 1 ; W [ 5 ][ 6 ] = - 2 ; $\\Theta(V+E)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 void DFS_TS ( const Graph & G , std :: vector < bool > & visit , stack < int > & S , int x ) { visit [ x ] = true ; //std::cout << x << ' '; // \uc21c\ud68c\ucd9c\ub825 for ( int next : G [ x ]) { if ( visit [ next ] != true ) { DFS_TS ( G , visit , S , next ); } } S . push ( x ); } std :: stack < int > topologicalsort ( const Graph & G ) { const int n = G . size (); std :: vector < bool > visit ; visit . resize ( n ); stack < int > S ; // \uc2e4\uc81c \uc815\ub82c\ub41c\uac12\uc774 \uc5ed\uc21c\uc73c\ub85c \ub4e4\uc5b4\uac00\uc788\ub2e4. for ( std :: size_t i = 1 ; i < n ; i ++ ) { if ( visit [ i ] != true ) { DFS_TS ( G , visit , S , i ); } } return S ; } void INITIALIZE_SINGLE_SOURCE ( const Graph & G , std :: vector < int >& Distance , int s ) { std :: fill ( Distance . begin (), Distance . begin () + Graph . size (), INF ); Distance [ s ] = 0 ; } void RELAX ( int u , int v , int w , std :: vector < int >& Distance ) { if ( Distance [ v ] > Distance [ u ] + w ) { Distance [ v ] = Distance [ u ] + w ; //predecessor_subgraph[v] = u; } } void DAG_SHORTEST_PATHS ( const Graph & G , std :: vector < std :: vector < int >>& W , std :: vector < int >& Distance , int s ) { std :: stack < int > S = topologicalsort ( G ); INITIALIZE_SINGLE_SOURCE ( G , Distance , s ); while ( ! S . empty ()) { int u = S . top (); S . pop (); for ( int v : G [ u ]) { RELAX ( u , v , W [ u ][ v ], Distance ); } } }","title":"24.2 Single-source shortest paths in directed acyclic graphs"},{"location":"Graph/24_SSSP/#243-dijkstras-algorithm","text":"\ucc38\uace0: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Running_time \uc6b0\uc120\uc21c\uc704\ud050 \uc0ac\uc6a9 $O(E\\log V)$ PQ\uc758 \ud0d1 \ub514\uc2a4\ud134\uc2a4\uac12\uc744 \uac31\uc2e0\uc2dc\ucf1c\uc57c\ud55c\ub2e4 \ub530\ub77c\uc11c \ubf51\uace0 \ub2e4\uc2dc\ub123\ub294\ub2e4. \ucc45\uc758 \uc758\uc0ac\ucf54\ub4dc\uc5d0 \uce58\uba85\uc801\uc778 \ubb38\uc81c\uac00 \ud558\ub098\uc788\ub294\ub370 \uc644\ud654\uc5d0\uc11c Q.decrease_priority\ub85c key \uac70\ub9ac\uac12\uc744 \uac31\uc2e0 \uc2dc\ucf1c\uc918\uc57c\ud55c\ub2e4. 1 2 3 4 5 6 7 8 9 10 11 12 13 void DIJK_RELAX ( int u , int v , int w , std :: vector < int >& Distance , std :: priority_queue < std :: pair < int , int > , std :: vector < std :: pair < int , int >> , std :: greater < std :: pair < int , int >>>& PQ ) { if (( Distance [ u ] != INF ) && ( Distance [ v ] > Distance [ u ] + w )) { Distance [ v ] = Distance [ u ] + w ; //predecessor_subgraph[v] = u; PQ . push ( std :: make_pair ( Distance [ v ], v )); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void DIJKSTRA ( const Graph & G , std :: vector < std :: vector < int >>& W , std :: vector < int > & Distance , int s ) { INITIALIZE_SINGLE_SOURCE ( G , Distance , s ); std :: priority_queue < std :: pair < int , int > , std :: vector < std :: pair < int , int >> , std :: greater < std :: pair < int , int >> > PQ ; //\uc815\uc810\uc758 \uac70\ub9ac, \uc815\uc810 for ( std :: size_t i = 1 ; i < G . size (); i ++ ) { PQ . push ( std :: make_pair ( Distance [ i ], i )); } while ( ! PQ . empty ()) { int u = PQ . top (). second ; PQ . pop (); for ( int v : G [ u ]) { DIJK_RELAX ( u , v , W [ u ][ v ], Distance , PQ ); } } }","title":"24.3 Dijkstra's algorithm"},{"location":"Graph/25_all_pairs_shortest_paths/","text":"All-Pairs Shortest Paths 1 2 3 4 5 6 7 8 { {}, { 0 , 0 , 3 , 8 , INF , - 4 }, { 0 , INF , 0 , INF , 1 , 7 }, { 0 , INF , 4 , 0 , INF , INF }, { 0 , 2 , INF , - 5 , 0 , INF }, { 0 , INF , INF , INF , 6 , 0 } }; 1 2 typedef std::vector<std::vector<int>> Matrix; // must NxN 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const int NIL = 0 ; const int INF = 100000000 ; void PRINT_ALL_PAIRS_SHORTEST_PATH ( Matrix pi , int i , int j ) { if ( i == j ) std :: cout << ' ' << i << ' ' ; else if ( pi [ i ][ j ] == NIL ) { std :: cout << \"no path from \" << i << \" to \" << j << \" exists\" << std :: endl ; } else { PRINT_ALL_PAIRS_SHORTEST_PATH ( pi , i , pi [ i ][ j ]); std :: cout << ' ' << j << ' ' ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iomanip> void print_matrix ( Matrix & m ) { const int n = m . size (); for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( m [ i ][ j ] == INF ) std :: cout << \"INF\" << ' ' ; else std :: cout << std :: setw ( 3 ) << m [ i ][ j ] << ' ' ; } std :: cout << '\\n' ; } std :: cout << '\\n' << '\\n' ; } 25.1 Shortest paths and matrix multiplication $O(V^3)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Matrix EXTEND_SHORTEST_PATHS ( Matrix & L , Matrix & W ) { const int n = L . size (); Matrix L_prime ( n , std :: vector < int > ( n , INF )); for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { for ( int k = 1 ; k < n ; k ++ ) { L_prime [ i ][ j ] = ( L_prime [ i ][ j ] < L [ i ][ k ] + W [ k ][ j ] ? L_prime [ i ][ j ] : L [ i ][ k ] + W [ k ][ j ]); } } } return L_prime ; } \ucd1d $O(V^4)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 //nxn 1~n MatrixSLOW_ALL_PAIRS_SHORTEST_PATHS ( Matrix & W ) { const int n = W . size (); std :: vector < Matrix > L ( n , Matrix ( n , std :: vector < int > ( n ))); L [ 1 ] = W ; for ( int m = 2 ; m < n ; m ++ ) { L [ m ] = EXTEND_SHORTEST_PATHS ( L [ m - 1 ], W ); } return L [ n - 1 ]; } \ucd1d $O(V^3 \\log (V))$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 MatrixFASTER_ALL_PAIRS_SHORTEST_PATHS ( Matrix & W ) { const int n = W . size () - 1 ; int a = 1 ; while ( a < n ) { a = a * 2 ; } std :: vector < Matrix > L ( a + 1 , Matrix ( n , std :: vector < int > ( n ))); L [ 1 ] = W ; int m = 1 ; while ( m < n - 1 ) { L [ 2 * m ] = EXTEND_SHORTEST_PATHS ( L [ m ], L [ m ]); m = m * 2 ; } return L [ m ]; } //25.1-6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void set_pi ( Matrix & W , std :: vector < std :: vector < int >> & L , Matrix & pi ) { const int n = L . size (); for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { for ( int k = 1 ; k < n ; k ++ ) { if (( L [ i ][ j ] - L [ i ][ k ]) == W [ k ][ j ]) { if ( W [ k ][ j ] != 0 && i != j ) { pi [ i ][ j ] = k ; } } } } } } //25.7 \uc804\uccb4 \ub2e4\uc2dc \uc9dc\uae30 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 //25.1-7 void EXTEND_SHORTEST_PATHS_pi ( Matrix & L , Matrix & W , Matrix & pi , Matrix * __L , Matrix * ___pi ) { const int n = L . size (); //Matrix L_prime; //L_prime.assign(n, std::vector<int>(n, INF)); for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { for ( int k = 1 ; k < n ; k ++ ) { if (( * __L )[ i ][ j ] > L [ i ][ k ] + W [ k ][ j ]) { ( * __L )[ i ][ j ] = ( L [ i ][ k ] + W [ k ][ j ]); ( * ___pi )[ i ][ j ] = k ; } } } } //return L_prime; } //nxn 1~n void SLOW_ALL_PAIRS_SHORTEST_PATHS_pi ( const Matrix & W , Matrix * out_pi , Matrix * out_L ) { const int n = W . size () - 1 ; std :: vector < Matrix > L ( n + 1 , Matrix ( n + 1 , std :: vector < int > ( n + 1 , INF ))); std :: vector < Matrix > pi ( n + 1 , Matrix ( n + 1 , std :: vector < int > ( n + 1 , INF ))); L [ 1 ] = W ; for ( int m = 2 ; m < n ; m ++ ) { EXTEND_SHORTEST_PATHS_pi ( L [ m - 1 ], W , pi [ m - 1 ], & L [ m ], & pi [ m ]); } out_L -> swap ( L [ n - 1 ]); out_pi -> swap ( pi [ n - 1 ]); } 25.1-8 space requirement Theta(n^2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Matrix FASTER_ALL_PAIRS_SHORTEST_PATHS ( Matrix & W ) { const int n = W . size () - 1 ; Matrix A ( n + 1 , std :: vector < int > ( n + 1 )) Matrix B ( W ); int m = 1 ; while ( m < n - 1 ) { A = EXTEND_SHORTEST_PATHS ( B , B ); m = m * 2 ; if ( m >= n - 1 ) { return A ; } B = EXTEND_SHORTEST_PATHS ( A , A ); m = m * 2 ; } return B ; } 25.1-9 25.1-8\uc5d0 \uc774\uc5b4\uc11c. no consider overflow; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 Matrix FASTER_ALL_PAIRS_SHORTEST_PATHS ( const Matrix & W ) { const int n = W . size () - 1 ; Matrix A = W , B = W , C = W , D = W ; int m = 1 ; while ( 1 ) { A = EXTEND_SHORTEST_PATHS ( B , B ); m = m * 2 ; if ( m > n - 1 ) { C = A ; break ; } B = EXTEND_SHORTEST_PATHS ( A , A ); m = m * 2 ; if ( m > n - 1 ) { C = B ; break ; } } D = EXTEND_SHORTEST_PATHS ( C , C ); print_matrix ( C ); print_matrix ( D ); bool chk_nwc = 0 ; for ( int i = 1 ; i <= n && ! chk_nwc ; i ++ ) { for ( int j = 1 ; j <= n && ! chk_nwc ; j ++ ) { if ( C [ i ][ j ] != D [ i ][ j ]) { chk_nwc = true ; } } } if ( chk_nwc ) std :: cout << \"the input graph contains a negative-weight cycle\" << std :: endl ; return C ; } 25.2 The Floyd-Warshall algorithm n = n+1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 MatrixFLOYD_WARSHALL ( const Matrix & W ) { const int n = W . size (); std :: vector < Matrix > D ( n , Matrix ( n , std :: vector < int > ( n ))); D [ 0 ] = W ; for ( int k = 1 ; k <= n ; k ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { D [ k ][ i ][ j ] = ( D [ k - 1 ][ i ][ j ] < D [ k - 1 ][ i ][ k ] + D [ k - 1 ][ k ][ j ] ? D [ k - 1 ][ i ][ j ] : D [ k - 1 ][ i ][ k ] + D [ k - 1 ][ k ][ j ]); } } } return D [ n - 1 ]; } Graph is nxn matrix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Matrix TRANSITIVE_CLOSURE ( Matrix & G ) { const int n = G . size (); std :: vector < Matrix > T ( n , Matrix ( n , std :: vector < int > ( n ))); for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if (( i == j ) || ( G [ i ][ j ] != 0 )) { T [ 0 ][ i ][ j ] = 1 ; } else { T [ 0 ][ i ][ j ] = 0 ; } } } for ( int k = 1 ; k < n ; k ++ ) { for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { T [ k ][ i ][ j ] = T [ k - 1 ][ i ][ j ] | ( T [ k - 1 ][ i ][ k ] & T [ k - 1 ][ k ][ j ]); } } } return T [ n - 1 ]; } 25.2-3 25.2-4\uc5d0 \uc774\uc5b4\uc11c. \uacf5\uac04\ubcf5\uc7a1\ub3c4 $O(n^3)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 Matrix FLOYD_WARSHALL_apostrophe_pi ( cosnt Matrix & W , Matrix & out_pi ) { const int n = W . size () - 1 ; Matrix D ( W ); std :: vector < Matrix > pi_prime ( n + 1 , Matrix ( n + 1 , std :: vector < int > ( n + 1 ))); for ( int k = 0 ; k <= n ; k ++ ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if (( i == j ) || ( pi_prime [ k ][ i ][ j ] == INF )) { pi_prime [ k ][ i ][ j ] = NIL ; } else { pi_prime [ k ][ i ][ j ] = k ; } } } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if (( D [ i ][ j ] != INF ) && ( i != j )) { pi_prime [ 0 ][ i ][ j ] = i ; } } } print_matrix ( pi_prime [ 0 ]); for ( int k = 1 ; k <= n ; k ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( D [ i ][ j ] > D [ i ][ k ] + D [ k ][ j ]) { D [ i ][ j ] = D [ i ][ k ] + D [ k ][ j ]; pi_prime [ k ][ i ][ j ] = pi_prime [ k - 1 ][ k ][ j ]; } else { pi_prime [ k ][ i ][ j ] = pi_prime [ k - 1 ][ i ][ j ]; } } } } out_pi . swap ( pi_prime [ n ]); return D ; } \uacf5\uac04\ubcf5\uc7a1\ub3c4 $O(n^2)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Matrix FLOYD_WARSHALL_apostrophe_pi ( const Matrix & W , Matrix & out_pi ) { const int n = W . size () - 1 ; Matrix D = W ; Matrix pi_prime ( n + 1 , std :: vector < int > ( n + 1 )); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if (( W [ i ][ j ] != INF ) && ( i != j )) { pi_prime [ i ][ j ] = i ; } } } print_matrix ( pi_prime ); for ( int k = 1 ; k <= n ; k ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( D [ i ][ j ] > D [ i ][ k ] + D [ k ][ j ]) { D [ i ][ j ] = D [ i ][ k ] + D [ k ][ j ]; pi_prime [ i ][ j ] = pi_prime [ k ][ j ]; } } } } out_pi . swap ( pi_prime ); return D ; } 25.2-4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Matrix FLOYD_WARSHALL_apostrophe ( const Matrix & W ) { const int n = W . size (); Matrix D ( W ); for ( int k = 1 ; k < n ; k ++ ) { for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { D [ i ][ j ] = ( D [ i ][ j ] < D [ i ][ k ] + D [ k ][ j ] ? D [ i ][ j ] : D [ i ][ k ] + D [ k ][ j ]); } } } return D ; } 25.3 Johnson's algorithm for sparse graphs \uc778\uc811\ub9ac\uc2a4\ud2b8 Graph+W\ud589\ub82c\uacfc \uc778\uc811\ub9ac\uc2a4\ud2b8 \uac00\uc911\uce58 \uadf8\ub798\ud504 \uac01\uac01\uc73c\ub85c \uc9dc\uc5ec\uc838\uc788\ub2e4 O(VElgV) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 void INITIALIZE_SINGLE_SOURCE ( const Graph & Graph , std :: vector < int >& Distance , int s ) { std :: fill ( Distance . begin (), Distance . begin () + Graph . size (), INF ); Distance [ s ] = 0 ; } void BF_RELAX ( int u , int v , int w , std :: vector < int >& Distance ) { if ( Distance [ v ] > Distance [ u ] + w ) { Distance [ v ] = Distance [ u ] + w ; } } //for johnson's alg bool BELLMAN_FORD ( const Graph & Graph , const Matrix & W , std :: vector < int > & Distance , int s ) { INITIALIZE_SINGLE_SOURCE ( Graph , Distance , s ); const std :: size_t n = Graph . size () - 1 ; for ( std :: size_t i = 1 ; i <= n ; i ++ ) // \uac04\uc120 u v w = Graph[v][] { for ( std :: size_t u = 0 ; u <= n ; u ++ ) { for ( int v : Graph [ u ]) { int w = W [ u ][ v ]; BF_RELAX ( u , v , w , Distance ); } } } for ( std :: size_t u = 1 ; u <= n ; u ++ ) { for ( int v : Graph [ u ]) { if (( Distance [ v ] > Distance [ u ] + W [ u ][ v ]) && Distance [ u ] != INF ) { Distance [ v ] = - 1 ; return false ; } } } return true ; } void DIJK_RELAX ( int u , int v , int w , std :: vector < int >& Distance , std :: priority_queue < std :: pair < int , int > , std :: vector < std :: pair < int , int >> , std :: greater < std :: pair < int , int >> >& PQ ) { if (( Distance [ u ] != INF ) && ( Distance [ v ] > Distance [ u ] + w )) { Distance [ v ] = Distance [ u ] + w ; //predecessor_subgraph[v] = u; PQ . push ( std :: make_pair ( Distance [ v ], v )); } } void DIJKSTRA ( const Graph & Graph , Matrix & W , std :: vector < int > & Distance , int s ) { INITIALIZE_SINGLE_SOURCE ( Graph , Distance , s ); std :: priority_queue < std :: pair < int , int > , std :: vector < std :: pair < int , int >> , std :: greater < std :: pair < int , int >> > PQ ; //\uc815\uc810\uc758 \uac70\ub9ac, \uc815\uc810 for ( std :: size_t i = 1 ; i < Graph . size (); i ++ ) { PQ . push ( std :: make_pair ( Distance [ i ], i )); } while ( ! PQ . empty ()) { int u = PQ . top (). second ; PQ . pop (); for ( int v : Graph [ u ]) { DIJK_RELAX ( u , v , W [ u ][ v ], Distance , PQ ); } } } Matrix JOHNSON ( const Matrix & Graph , Matrix & W ) { // Matrix D ( n + 1 , std :: vector < int > ( n + 1 )); Matrix G_apostrophe ( Graph ); const std :: size_t n = Graph . size () - 1 ; for ( std :: size_t i = 1 ; i <= n ; i ++ ) { W [ 0 ]. resize ( n + 1 ); G_apostrophe [ 0 ]. push_back ( i ); } std :: vector < int > Distance ( n + 1 ); // and h(x) if ( BELLMAN_FORD ( G_apostrophe , W , Distance , 0 ) == false ) { std :: cout << \"the input graph contains a negative-weight cycle\" << std :: endl ; } else { std :: vector < int > h = Distance ; Matrix W_het ( W ); Matrix D_het ( n + 1 std :: vector < int > ( n + 1 )); for ( std :: size_t u = 1 ; u <= n ; u ++ ) { for ( int v : Graph [ u ]) { W_het [ u ][ v ] += ( h [ u ] - h [ v ]); } } for ( std :: size_t u = 1 ; u <= n ; u ++ ) { DIJKSTRA ( Graph , W_het , D_het [ u ], u ); for ( std :: size_t v = 1 ; v <= n ; v ++ ) { D [ u ][ v ] = D_het [ u ][ v ] + h [ v ] - h [ u ]; } } } return D ; } pair(\uc815\uc810,\uac00\uc911\uce58) \uac00\uc911\uce58 \uc778\uc811\uadf8\ub798\ud504, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 void INITIALIZE_SINGLE_SOURCE ( std :: vector < std :: vector < std :: pair < int , int >>>& Graph , std :: vector < int >& Distance , int s ) { for ( std :: size_t i = 1 ; i < Graph . size (); i ++ ) { Distance [ i ] = INF ; } Distance [ s ] = 0 ; } void BF_RELAX ( int u , int v , int w , std :: vector < int >& Distance ) { if ( Distance [ v ] > Distance [ u ] + w ) { Distance [ v ] = Distance [ u ] + w ; } } bool BELLMAN_FORD ( std :: vector < std :: vector < std :: pair < int , int >>>& Graph , std :: vector < int > & Distance , int s ) { INITIALIZE_SINGLE_SOURCE ( Graph , Distance , s ); const int n = Graph . size () - 1 ; for ( std :: size_t i = 1 ; i <= n ; i ++ ) // \uac04\uc120 u v w = Graph[v][] { for ( std :: size_t u = 0 ; u <= n ; u ++ ) { const int sub_size = Graph [ u ]. size (); for ( std :: size_t j = 0 ; j < sub_size ; j ++ ) { int v = Graph [ u ][ j ]. first ; int w = Graph [ u ][ j ]. second ; BF_RELAX ( u , v , w , Distance ); } } } for ( std :: size_t u = 1 ; u <= n ; u ++ ) { const int sub_size = Graph [ u ]. size (); for ( std :: size_t j = 0 ; j < sub_size ; j ++ ) { int v = Graph [ u ][ j ]. first ; if (( Distance [ v ] > Distance [ u ] + Graph [ u ][ j ]. second ) && Distance [ u ] != INF ) { Distance [ v ] = - 1 ; return false ; } } } return true ; } void DIJK_RELAX ( int u , int v , int w , std :: vector < int > & Distance , std :: priority_queue < std :: pair < int , int > , std :: vector < std :: pair < int , int >> , std :: greater < std :: pair < int , int >> > & PQ ) { if (( Distance [ u ] != INF ) && ( Distance [ v ] > Distance [ u ] + w )) { Distance [ v ] = Distance [ u ] + w ; PQ . push ( std :: make_pair ( Distance [ v ], v )); } } void DIJKSTRA ( std :: vector < std :: vector < std :: pair < int , int >>>& Graph , std :: vector < int > & Distance , int s ) { INITIALIZE_SINGLE_SOURCE ( Graph , Distance , s ); std :: priority_queue < std :: pair < int , int > , std :: vector < std :: pair < int , int >> , std :: greater < std :: pair < int , int >> > PQ ; //\uc815\uc810\uc758 \uac70\ub9ac, \uc815\uc810 for ( int i = 1 ; i < Graph . size (); i ++ ) { PQ . push ( std :: make_pair ( Distance [ i ], i )); } while ( ! PQ . empty ()) { int u = PQ . top (). second ; PQ . pop (); for ( int v = 0 ; v < Graph [ u ]. size (); v ++ ) { DIJK_RELAX ( u , Graph [ u ][ v ]. first , Graph [ u ][ v ]. second , Distance , PQ ); } } } //graph pair(\uc815\uc810,\uac00\uc911\uce58) Matrix JOHNSON ( std :: vector < std :: vector < std :: pair < int , int >>>& Graph ) { //Matrix &W Matrix D ( n + 1 , std :: vector < int > ( n + 1 )); std :: vector < std :: vector < std :: pair < int , int >>> G_apostrophe ( Graph ); const int n = Graph . size () - 1 ; for ( int i = 1 ; i <= n ; i ++ ) { G_apostrophe [ 0 ]. push_back ( std :: make_pair ( i , 0 )); } std :: vector < int > Distance ( n + 1 ); // and h(x) if ( BELLMAN_FORD ( G_apostrophe , Distance , 0 ) == false ) { std :: cout << \"the input graph contains a negative-weight cycle\" << std :: endl ; } else { std :: vector < int > h ( Distance ); std :: vector < std :: vector < std :: pair < int , int >>> Graph_het = Graph ; Matrix D_het ( n + 1 , std :: vector < int > ( n + 1 )); for ( int i = 1 ; i <= n ; i ++ ) { const int sub_size = Graph_het [ i ]. size (); for ( int j = 0 ; j < sub_size ; j ++ ) { Graph_het [ i ][ j ]. second += ( h [ i ] - h [ Graph_het [ i ][ j ]. first ]); } } for ( int u = 1 ; u <= n ; u ++ ) { DIJKSTRA ( Graph_het , D_het [ u ], u ); for ( int v = 1 ; v <= n ; v ++ ) { D [ u ][ v ] = D_het [ u ][ v ] + h [ v ] - h [ u ]; } } } return D ; }","title":"25 All-Pairs Shortest Paths"},{"location":"Graph/25_all_pairs_shortest_paths/#all-pairs-shortest-paths","text":"1 2 3 4 5 6 7 8 { {}, { 0 , 0 , 3 , 8 , INF , - 4 }, { 0 , INF , 0 , INF , 1 , 7 }, { 0 , INF , 4 , 0 , INF , INF }, { 0 , 2 , INF , - 5 , 0 , INF }, { 0 , INF , INF , INF , 6 , 0 } }; 1 2 typedef std::vector<std::vector<int>> Matrix; // must NxN 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const int NIL = 0 ; const int INF = 100000000 ; void PRINT_ALL_PAIRS_SHORTEST_PATH ( Matrix pi , int i , int j ) { if ( i == j ) std :: cout << ' ' << i << ' ' ; else if ( pi [ i ][ j ] == NIL ) { std :: cout << \"no path from \" << i << \" to \" << j << \" exists\" << std :: endl ; } else { PRINT_ALL_PAIRS_SHORTEST_PATH ( pi , i , pi [ i ][ j ]); std :: cout << ' ' << j << ' ' ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iomanip> void print_matrix ( Matrix & m ) { const int n = m . size (); for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( m [ i ][ j ] == INF ) std :: cout << \"INF\" << ' ' ; else std :: cout << std :: setw ( 3 ) << m [ i ][ j ] << ' ' ; } std :: cout << '\\n' ; } std :: cout << '\\n' << '\\n' ; }","title":"All-Pairs Shortest Paths"},{"location":"Graph/25_all_pairs_shortest_paths/#251-shortest-paths-and-matrix-multiplication","text":"$O(V^3)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Matrix EXTEND_SHORTEST_PATHS ( Matrix & L , Matrix & W ) { const int n = L . size (); Matrix L_prime ( n , std :: vector < int > ( n , INF )); for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { for ( int k = 1 ; k < n ; k ++ ) { L_prime [ i ][ j ] = ( L_prime [ i ][ j ] < L [ i ][ k ] + W [ k ][ j ] ? L_prime [ i ][ j ] : L [ i ][ k ] + W [ k ][ j ]); } } } return L_prime ; } \ucd1d $O(V^4)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 //nxn 1~n MatrixSLOW_ALL_PAIRS_SHORTEST_PATHS ( Matrix & W ) { const int n = W . size (); std :: vector < Matrix > L ( n , Matrix ( n , std :: vector < int > ( n ))); L [ 1 ] = W ; for ( int m = 2 ; m < n ; m ++ ) { L [ m ] = EXTEND_SHORTEST_PATHS ( L [ m - 1 ], W ); } return L [ n - 1 ]; } \ucd1d $O(V^3 \\log (V))$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 MatrixFASTER_ALL_PAIRS_SHORTEST_PATHS ( Matrix & W ) { const int n = W . size () - 1 ; int a = 1 ; while ( a < n ) { a = a * 2 ; } std :: vector < Matrix > L ( a + 1 , Matrix ( n , std :: vector < int > ( n ))); L [ 1 ] = W ; int m = 1 ; while ( m < n - 1 ) { L [ 2 * m ] = EXTEND_SHORTEST_PATHS ( L [ m ], L [ m ]); m = m * 2 ; } return L [ m ]; } //25.1-6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void set_pi ( Matrix & W , std :: vector < std :: vector < int >> & L , Matrix & pi ) { const int n = L . size (); for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { for ( int k = 1 ; k < n ; k ++ ) { if (( L [ i ][ j ] - L [ i ][ k ]) == W [ k ][ j ]) { if ( W [ k ][ j ] != 0 && i != j ) { pi [ i ][ j ] = k ; } } } } } } //25.7 \uc804\uccb4 \ub2e4\uc2dc \uc9dc\uae30 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 //25.1-7 void EXTEND_SHORTEST_PATHS_pi ( Matrix & L , Matrix & W , Matrix & pi , Matrix * __L , Matrix * ___pi ) { const int n = L . size (); //Matrix L_prime; //L_prime.assign(n, std::vector<int>(n, INF)); for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { for ( int k = 1 ; k < n ; k ++ ) { if (( * __L )[ i ][ j ] > L [ i ][ k ] + W [ k ][ j ]) { ( * __L )[ i ][ j ] = ( L [ i ][ k ] + W [ k ][ j ]); ( * ___pi )[ i ][ j ] = k ; } } } } //return L_prime; } //nxn 1~n void SLOW_ALL_PAIRS_SHORTEST_PATHS_pi ( const Matrix & W , Matrix * out_pi , Matrix * out_L ) { const int n = W . size () - 1 ; std :: vector < Matrix > L ( n + 1 , Matrix ( n + 1 , std :: vector < int > ( n + 1 , INF ))); std :: vector < Matrix > pi ( n + 1 , Matrix ( n + 1 , std :: vector < int > ( n + 1 , INF ))); L [ 1 ] = W ; for ( int m = 2 ; m < n ; m ++ ) { EXTEND_SHORTEST_PATHS_pi ( L [ m - 1 ], W , pi [ m - 1 ], & L [ m ], & pi [ m ]); } out_L -> swap ( L [ n - 1 ]); out_pi -> swap ( pi [ n - 1 ]); } 25.1-8 space requirement Theta(n^2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Matrix FASTER_ALL_PAIRS_SHORTEST_PATHS ( Matrix & W ) { const int n = W . size () - 1 ; Matrix A ( n + 1 , std :: vector < int > ( n + 1 )) Matrix B ( W ); int m = 1 ; while ( m < n - 1 ) { A = EXTEND_SHORTEST_PATHS ( B , B ); m = m * 2 ; if ( m >= n - 1 ) { return A ; } B = EXTEND_SHORTEST_PATHS ( A , A ); m = m * 2 ; } return B ; } 25.1-9 25.1-8\uc5d0 \uc774\uc5b4\uc11c. no consider overflow; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 Matrix FASTER_ALL_PAIRS_SHORTEST_PATHS ( const Matrix & W ) { const int n = W . size () - 1 ; Matrix A = W , B = W , C = W , D = W ; int m = 1 ; while ( 1 ) { A = EXTEND_SHORTEST_PATHS ( B , B ); m = m * 2 ; if ( m > n - 1 ) { C = A ; break ; } B = EXTEND_SHORTEST_PATHS ( A , A ); m = m * 2 ; if ( m > n - 1 ) { C = B ; break ; } } D = EXTEND_SHORTEST_PATHS ( C , C ); print_matrix ( C ); print_matrix ( D ); bool chk_nwc = 0 ; for ( int i = 1 ; i <= n && ! chk_nwc ; i ++ ) { for ( int j = 1 ; j <= n && ! chk_nwc ; j ++ ) { if ( C [ i ][ j ] != D [ i ][ j ]) { chk_nwc = true ; } } } if ( chk_nwc ) std :: cout << \"the input graph contains a negative-weight cycle\" << std :: endl ; return C ; }","title":"25.1 Shortest paths and matrix multiplication"},{"location":"Graph/25_all_pairs_shortest_paths/#252-the-floyd-warshall-algorithm","text":"n = n+1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 MatrixFLOYD_WARSHALL ( const Matrix & W ) { const int n = W . size (); std :: vector < Matrix > D ( n , Matrix ( n , std :: vector < int > ( n ))); D [ 0 ] = W ; for ( int k = 1 ; k <= n ; k ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { D [ k ][ i ][ j ] = ( D [ k - 1 ][ i ][ j ] < D [ k - 1 ][ i ][ k ] + D [ k - 1 ][ k ][ j ] ? D [ k - 1 ][ i ][ j ] : D [ k - 1 ][ i ][ k ] + D [ k - 1 ][ k ][ j ]); } } } return D [ n - 1 ]; } Graph is nxn matrix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Matrix TRANSITIVE_CLOSURE ( Matrix & G ) { const int n = G . size (); std :: vector < Matrix > T ( n , Matrix ( n , std :: vector < int > ( n ))); for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if (( i == j ) || ( G [ i ][ j ] != 0 )) { T [ 0 ][ i ][ j ] = 1 ; } else { T [ 0 ][ i ][ j ] = 0 ; } } } for ( int k = 1 ; k < n ; k ++ ) { for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { T [ k ][ i ][ j ] = T [ k - 1 ][ i ][ j ] | ( T [ k - 1 ][ i ][ k ] & T [ k - 1 ][ k ][ j ]); } } } return T [ n - 1 ]; } 25.2-3 25.2-4\uc5d0 \uc774\uc5b4\uc11c. \uacf5\uac04\ubcf5\uc7a1\ub3c4 $O(n^3)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 Matrix FLOYD_WARSHALL_apostrophe_pi ( cosnt Matrix & W , Matrix & out_pi ) { const int n = W . size () - 1 ; Matrix D ( W ); std :: vector < Matrix > pi_prime ( n + 1 , Matrix ( n + 1 , std :: vector < int > ( n + 1 ))); for ( int k = 0 ; k <= n ; k ++ ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if (( i == j ) || ( pi_prime [ k ][ i ][ j ] == INF )) { pi_prime [ k ][ i ][ j ] = NIL ; } else { pi_prime [ k ][ i ][ j ] = k ; } } } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if (( D [ i ][ j ] != INF ) && ( i != j )) { pi_prime [ 0 ][ i ][ j ] = i ; } } } print_matrix ( pi_prime [ 0 ]); for ( int k = 1 ; k <= n ; k ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( D [ i ][ j ] > D [ i ][ k ] + D [ k ][ j ]) { D [ i ][ j ] = D [ i ][ k ] + D [ k ][ j ]; pi_prime [ k ][ i ][ j ] = pi_prime [ k - 1 ][ k ][ j ]; } else { pi_prime [ k ][ i ][ j ] = pi_prime [ k - 1 ][ i ][ j ]; } } } } out_pi . swap ( pi_prime [ n ]); return D ; } \uacf5\uac04\ubcf5\uc7a1\ub3c4 $O(n^2)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Matrix FLOYD_WARSHALL_apostrophe_pi ( const Matrix & W , Matrix & out_pi ) { const int n = W . size () - 1 ; Matrix D = W ; Matrix pi_prime ( n + 1 , std :: vector < int > ( n + 1 )); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if (( W [ i ][ j ] != INF ) && ( i != j )) { pi_prime [ i ][ j ] = i ; } } } print_matrix ( pi_prime ); for ( int k = 1 ; k <= n ; k ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( D [ i ][ j ] > D [ i ][ k ] + D [ k ][ j ]) { D [ i ][ j ] = D [ i ][ k ] + D [ k ][ j ]; pi_prime [ i ][ j ] = pi_prime [ k ][ j ]; } } } } out_pi . swap ( pi_prime ); return D ; } 25.2-4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Matrix FLOYD_WARSHALL_apostrophe ( const Matrix & W ) { const int n = W . size (); Matrix D ( W ); for ( int k = 1 ; k < n ; k ++ ) { for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { D [ i ][ j ] = ( D [ i ][ j ] < D [ i ][ k ] + D [ k ][ j ] ? D [ i ][ j ] : D [ i ][ k ] + D [ k ][ j ]); } } } return D ; }","title":"25.2 The Floyd-Warshall algorithm"},{"location":"Graph/25_all_pairs_shortest_paths/#253-johnsons-algorithm-for-sparse-graphs","text":"\uc778\uc811\ub9ac\uc2a4\ud2b8 Graph+W\ud589\ub82c\uacfc \uc778\uc811\ub9ac\uc2a4\ud2b8 \uac00\uc911\uce58 \uadf8\ub798\ud504 \uac01\uac01\uc73c\ub85c \uc9dc\uc5ec\uc838\uc788\ub2e4 O(VElgV) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 void INITIALIZE_SINGLE_SOURCE ( const Graph & Graph , std :: vector < int >& Distance , int s ) { std :: fill ( Distance . begin (), Distance . begin () + Graph . size (), INF ); Distance [ s ] = 0 ; } void BF_RELAX ( int u , int v , int w , std :: vector < int >& Distance ) { if ( Distance [ v ] > Distance [ u ] + w ) { Distance [ v ] = Distance [ u ] + w ; } } //for johnson's alg bool BELLMAN_FORD ( const Graph & Graph , const Matrix & W , std :: vector < int > & Distance , int s ) { INITIALIZE_SINGLE_SOURCE ( Graph , Distance , s ); const std :: size_t n = Graph . size () - 1 ; for ( std :: size_t i = 1 ; i <= n ; i ++ ) // \uac04\uc120 u v w = Graph[v][] { for ( std :: size_t u = 0 ; u <= n ; u ++ ) { for ( int v : Graph [ u ]) { int w = W [ u ][ v ]; BF_RELAX ( u , v , w , Distance ); } } } for ( std :: size_t u = 1 ; u <= n ; u ++ ) { for ( int v : Graph [ u ]) { if (( Distance [ v ] > Distance [ u ] + W [ u ][ v ]) && Distance [ u ] != INF ) { Distance [ v ] = - 1 ; return false ; } } } return true ; } void DIJK_RELAX ( int u , int v , int w , std :: vector < int >& Distance , std :: priority_queue < std :: pair < int , int > , std :: vector < std :: pair < int , int >> , std :: greater < std :: pair < int , int >> >& PQ ) { if (( Distance [ u ] != INF ) && ( Distance [ v ] > Distance [ u ] + w )) { Distance [ v ] = Distance [ u ] + w ; //predecessor_subgraph[v] = u; PQ . push ( std :: make_pair ( Distance [ v ], v )); } } void DIJKSTRA ( const Graph & Graph , Matrix & W , std :: vector < int > & Distance , int s ) { INITIALIZE_SINGLE_SOURCE ( Graph , Distance , s ); std :: priority_queue < std :: pair < int , int > , std :: vector < std :: pair < int , int >> , std :: greater < std :: pair < int , int >> > PQ ; //\uc815\uc810\uc758 \uac70\ub9ac, \uc815\uc810 for ( std :: size_t i = 1 ; i < Graph . size (); i ++ ) { PQ . push ( std :: make_pair ( Distance [ i ], i )); } while ( ! PQ . empty ()) { int u = PQ . top (). second ; PQ . pop (); for ( int v : Graph [ u ]) { DIJK_RELAX ( u , v , W [ u ][ v ], Distance , PQ ); } } } Matrix JOHNSON ( const Matrix & Graph , Matrix & W ) { // Matrix D ( n + 1 , std :: vector < int > ( n + 1 )); Matrix G_apostrophe ( Graph ); const std :: size_t n = Graph . size () - 1 ; for ( std :: size_t i = 1 ; i <= n ; i ++ ) { W [ 0 ]. resize ( n + 1 ); G_apostrophe [ 0 ]. push_back ( i ); } std :: vector < int > Distance ( n + 1 ); // and h(x) if ( BELLMAN_FORD ( G_apostrophe , W , Distance , 0 ) == false ) { std :: cout << \"the input graph contains a negative-weight cycle\" << std :: endl ; } else { std :: vector < int > h = Distance ; Matrix W_het ( W ); Matrix D_het ( n + 1 std :: vector < int > ( n + 1 )); for ( std :: size_t u = 1 ; u <= n ; u ++ ) { for ( int v : Graph [ u ]) { W_het [ u ][ v ] += ( h [ u ] - h [ v ]); } } for ( std :: size_t u = 1 ; u <= n ; u ++ ) { DIJKSTRA ( Graph , W_het , D_het [ u ], u ); for ( std :: size_t v = 1 ; v <= n ; v ++ ) { D [ u ][ v ] = D_het [ u ][ v ] + h [ v ] - h [ u ]; } } } return D ; } pair(\uc815\uc810,\uac00\uc911\uce58) \uac00\uc911\uce58 \uc778\uc811\uadf8\ub798\ud504, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 void INITIALIZE_SINGLE_SOURCE ( std :: vector < std :: vector < std :: pair < int , int >>>& Graph , std :: vector < int >& Distance , int s ) { for ( std :: size_t i = 1 ; i < Graph . size (); i ++ ) { Distance [ i ] = INF ; } Distance [ s ] = 0 ; } void BF_RELAX ( int u , int v , int w , std :: vector < int >& Distance ) { if ( Distance [ v ] > Distance [ u ] + w ) { Distance [ v ] = Distance [ u ] + w ; } } bool BELLMAN_FORD ( std :: vector < std :: vector < std :: pair < int , int >>>& Graph , std :: vector < int > & Distance , int s ) { INITIALIZE_SINGLE_SOURCE ( Graph , Distance , s ); const int n = Graph . size () - 1 ; for ( std :: size_t i = 1 ; i <= n ; i ++ ) // \uac04\uc120 u v w = Graph[v][] { for ( std :: size_t u = 0 ; u <= n ; u ++ ) { const int sub_size = Graph [ u ]. size (); for ( std :: size_t j = 0 ; j < sub_size ; j ++ ) { int v = Graph [ u ][ j ]. first ; int w = Graph [ u ][ j ]. second ; BF_RELAX ( u , v , w , Distance ); } } } for ( std :: size_t u = 1 ; u <= n ; u ++ ) { const int sub_size = Graph [ u ]. size (); for ( std :: size_t j = 0 ; j < sub_size ; j ++ ) { int v = Graph [ u ][ j ]. first ; if (( Distance [ v ] > Distance [ u ] + Graph [ u ][ j ]. second ) && Distance [ u ] != INF ) { Distance [ v ] = - 1 ; return false ; } } } return true ; } void DIJK_RELAX ( int u , int v , int w , std :: vector < int > & Distance , std :: priority_queue < std :: pair < int , int > , std :: vector < std :: pair < int , int >> , std :: greater < std :: pair < int , int >> > & PQ ) { if (( Distance [ u ] != INF ) && ( Distance [ v ] > Distance [ u ] + w )) { Distance [ v ] = Distance [ u ] + w ; PQ . push ( std :: make_pair ( Distance [ v ], v )); } } void DIJKSTRA ( std :: vector < std :: vector < std :: pair < int , int >>>& Graph , std :: vector < int > & Distance , int s ) { INITIALIZE_SINGLE_SOURCE ( Graph , Distance , s ); std :: priority_queue < std :: pair < int , int > , std :: vector < std :: pair < int , int >> , std :: greater < std :: pair < int , int >> > PQ ; //\uc815\uc810\uc758 \uac70\ub9ac, \uc815\uc810 for ( int i = 1 ; i < Graph . size (); i ++ ) { PQ . push ( std :: make_pair ( Distance [ i ], i )); } while ( ! PQ . empty ()) { int u = PQ . top (). second ; PQ . pop (); for ( int v = 0 ; v < Graph [ u ]. size (); v ++ ) { DIJK_RELAX ( u , Graph [ u ][ v ]. first , Graph [ u ][ v ]. second , Distance , PQ ); } } } //graph pair(\uc815\uc810,\uac00\uc911\uce58) Matrix JOHNSON ( std :: vector < std :: vector < std :: pair < int , int >>>& Graph ) { //Matrix &W Matrix D ( n + 1 , std :: vector < int > ( n + 1 )); std :: vector < std :: vector < std :: pair < int , int >>> G_apostrophe ( Graph ); const int n = Graph . size () - 1 ; for ( int i = 1 ; i <= n ; i ++ ) { G_apostrophe [ 0 ]. push_back ( std :: make_pair ( i , 0 )); } std :: vector < int > Distance ( n + 1 ); // and h(x) if ( BELLMAN_FORD ( G_apostrophe , Distance , 0 ) == false ) { std :: cout << \"the input graph contains a negative-weight cycle\" << std :: endl ; } else { std :: vector < int > h ( Distance ); std :: vector < std :: vector < std :: pair < int , int >>> Graph_het = Graph ; Matrix D_het ( n + 1 , std :: vector < int > ( n + 1 )); for ( int i = 1 ; i <= n ; i ++ ) { const int sub_size = Graph_het [ i ]. size (); for ( int j = 0 ; j < sub_size ; j ++ ) { Graph_het [ i ][ j ]. second += ( h [ i ] - h [ Graph_het [ i ][ j ]. first ]); } } for ( int u = 1 ; u <= n ; u ++ ) { DIJKSTRA ( Graph_het , D_het [ u ], u ); for ( int v = 1 ; v <= n ; v ++ ) { D [ u ][ v ] = D_het [ u ][ v ] + h [ v ] - h [ u ]; } } } return D ; }","title":"25.3 Johnson's algorithm for sparse graphs"},{"location":"Graph/26_maximum_flow/","text":"26 Maximum Flow 26.1 Flow networks 26.2 The Ford-Fulkerson method Edmonds Karp $O(VE^2)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 constexpr long long INF = 0x7FFF ' FFFF ; // 'FFFF'FFFF; constexpr int MAX_V = 1002 ; std :: vector < int > adj [ MAX_V ]; int c [ MAX_V ][ MAX_V ]; int f [ MAX_V ][ MAX_V ]; int p [ MAX_V ]; bool findAugmentingPathBFS ( const int S , const int T ) { fill ( p , p + MAX_V , - 1 ); queue < int > Q ; Q . push ( S ); while ( ! Q . empty () && p [ T ] == - 1 ) { int curr = Q . front (); Q . pop (); if ( curr == T ) break ; for ( int next : adj [ curr ]) { if ( c [ curr ][ next ] - f [ curr ][ next ] > 0 && p [ next ] == - 1 ) { Q . push ( next ); p [ next ] = curr ; } } } return ( p [ T ] != - 1 ); } int Edmonds_Karp ( const int S , const int T ) { int maxFlow = 0 ; while ( findAugmentingPathBFS ( S , T )) { int c_f_p = INF ; for ( int i = T ; i != S ; i = p [ i ]) c_f_p = min ( c_f_p , c [ p [ i ]][ i ] - f [ p [ i ]][ i ]); for ( int i = T ; i != S ; i = p [ i ]) { f [ p [ i ]][ i ] += c_f_p ; f [ i ][ p [ i ]] -= c_f_p ; } maxFlow += c_f_p ; } return maxFlow ; } 26.3 Maximum bipartite matching 26.4 Push-relabel algorithms 26.5 The relabel-to-front algorithm","title":"26 Maximum Flow"},{"location":"Graph/26_maximum_flow/#26-maximum-flow","text":"","title":"26 Maximum Flow"},{"location":"Graph/26_maximum_flow/#261-flow-networks","text":"","title":"26.1 Flow networks"},{"location":"Graph/26_maximum_flow/#262-the-ford-fulkerson-method","text":"Edmonds Karp $O(VE^2)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 constexpr long long INF = 0x7FFF ' FFFF ; // 'FFFF'FFFF; constexpr int MAX_V = 1002 ; std :: vector < int > adj [ MAX_V ]; int c [ MAX_V ][ MAX_V ]; int f [ MAX_V ][ MAX_V ]; int p [ MAX_V ]; bool findAugmentingPathBFS ( const int S , const int T ) { fill ( p , p + MAX_V , - 1 ); queue < int > Q ; Q . push ( S ); while ( ! Q . empty () && p [ T ] == - 1 ) { int curr = Q . front (); Q . pop (); if ( curr == T ) break ; for ( int next : adj [ curr ]) { if ( c [ curr ][ next ] - f [ curr ][ next ] > 0 && p [ next ] == - 1 ) { Q . push ( next ); p [ next ] = curr ; } } } return ( p [ T ] != - 1 ); } int Edmonds_Karp ( const int S , const int T ) { int maxFlow = 0 ; while ( findAugmentingPathBFS ( S , T )) { int c_f_p = INF ; for ( int i = T ; i != S ; i = p [ i ]) c_f_p = min ( c_f_p , c [ p [ i ]][ i ] - f [ p [ i ]][ i ]); for ( int i = T ; i != S ; i = p [ i ]) { f [ p [ i ]][ i ] += c_f_p ; f [ i ][ p [ i ]] -= c_f_p ; } maxFlow += c_f_p ; } return maxFlow ; }","title":"26.2 The Ford-Fulkerson method"},{"location":"Graph/26_maximum_flow/#263-maximum-bipartite-matching","text":"","title":"26.3 Maximum bipartite matching"},{"location":"Graph/26_maximum_flow/#264-push-relabel-algorithms","text":"","title":"26.4 Push-relabel algorithms"},{"location":"Graph/26_maximum_flow/#265-the-relabel-to-front-algorithm","text":"","title":"26.5 The relabel-to-front algorithm"},{"location":"ch12/readme/","text":"12.1 What is a binary search tree? 1 2 3 4 5 6 7 struct Node { Node * right_large ; // key >= int key ; Node * left_small ; // key < Node * parent ; }; 1 2 3 4 5 6 7 8 9 void BST :: INORDER_TREE_WALK ( Node * x ) { if ( x != NIL ) { INORDER_TREE_WALK ( x -> left_small ); std :: cout << x -> key << ' ' ; INORDER_TREE_WALK ( x -> right_large ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 void BST :: preorder () //\uc804\uc704\uc21c\ud68c { if ( ROOT == NIL ) return ; preorder_procedure ( ROOT ); std :: cout << '\\n' ; } void BST :: Inorder () //\uc911\uc704\uc21c\ud68c { if ( ROOT == NIL ) return ; inorder_procedure ( ROOT ); std :: cout << '\\n' ; } void BST :: postorder () //\ud6c4\uc704\uc21c\ud68c { if ( ROOT == NIL ) return ; postorder_procedure ( ROOT ); std :: cout << '\\n' ; } void BST :: inorder_procedure ( Node * _node ) { if ( _node -> left_small != NIL ) inorder_procedure ( _node -> left_small ); std :: cout << _node -> key << \" \" ; if ( _node -> right_large != NIL ) inorder_procedure ( _node -> right_large ); } /* 1.\ub178\ub4dc\ub97c \ubc29\ubb38\ud55c\ub2e4. 2.\uc67c\ucabd \uc11c\ube0c \ud2b8\ub9ac\ub97c \uc911\uc704 \uc21c\ud68c\ud55c\ub2e4. 3.\uc624\ub978\ucabd \uc11c\ube0c \ud2b8\ub9ac\ub97c \uc911\uc704 \uc21c\ud68c\ud55c\ub2e4. */ void BST :: preorder_procedure ( Node * _node ) { std :: cout << _node -> key << \" \" ; if ( _node -> left_small != NIL ) preorder_procedure ( _node -> left_small ); if ( _node -> right_large != NIL ) preorder_procedure ( _node -> right_large ); } /* \uc67c\ucabd \uc11c\ube0c \ud2b8\ub9ac\ub97c \ud6c4\uc704 \uc21c\ud68c\ud55c\ub2e4. \uc624\ub978\ucabd \uc11c\ube0c \ud2b8\ub9ac\ub97c \ud6c4\uc704 \uc21c\ud68c\ud55c\ub2e4. \ub178\ub4dc\ub97c \ubc29\ubb38\ud55c\ub2e4. */ void BST :: postorder_procedure ( Node * _node ) { if ( _node -> left_small != NIL ) postorder_procedure ( _node -> left_small ); if ( _node -> right_large != NIL ) postorder_procedure ( _node -> right_large ); std :: cout << _node -> key << \" \" ; } //recursion -> while 12.2 Querying a binary search tree 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Node * BST :: TREE_SEARCH ( Node * x , int k ) { if ( x == NIL || k == x -> key ) { return x ; } if ( k < x -> key ) { return TREE_SEARCH ( x -> left_small , k ); } else { return TREE_SEARCH ( x -> right_large , k ); } } 1 2 3 4 5 6 7 8 9 10 11 12 Node * BST :: ITERATIVE_TREE_SEARCH ( Node * x , int k ) { while ( x != NIL && k != x -> key ) { if ( k < x -> key ) { x = x -> left_small ; } else x = x -> right_large ; } return x ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Node * BST :: TREE_MINIMUM ( Node * x ) // \uc11c\ube0c\ud2b8\ub9ac\uc758 \ucd5c\uc19f\uac12 \ubc18\ud658 { while ( x -> left_small != NIL ) { x = x -> left_small ; } return x ; } Node * BST :: TREE_MAXIMUM ( Node * x ) // \uc11c\ube0c\ud2b8\ub9ac\uc758 \ucd5c\ub313\uac12 \ubc18\ud658 { while ( x -> right_large != NIL ) { x = x -> right_large ; } return x ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Node * BST :: TREE_SUCCESSOR ( Node * x ) // \uc9c1\ud6c4\ub178\ub4dc { if ( x -> right_large != NIL ) { return TREE_MINIMUM ( x -> right_large ); } Node * y = x -> parent ; while ( y != NIL && x == y -> right_large ) //\ub8e8\ud2b8\uac00\uc544\ub2c8\uace0 \uc624\ub978\ucabd\ub178\ub4dc\uc774\uba74 { x = y ; y = y -> parent ; } return y ; } //12.2-3 Node * BST :: TREE_PREDECESSOR ( Node * x ) //\uc9c1\uc804\ub178\ub4dc { if ( x -> left_small != NIL ) { return TREE_MAXIMUM ( x -> left_small ); } Node * y = x -> parent ; while ( y != NIL && x == y -> left_small ) //\ub8e8\ud2b8\uac00\uc544\ub2c8\uace0 \uc624\ub978\ucabd\ub178\ub4dc\uc774\uba74 { x = y ; y = y -> parent ; } return y ; } 12.3 Insertion and deletion 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void BST :: TREE_INSERT ( Node * z ) // \ucc45\uc5d0 \ub098\uc624\ub294 \uc0bd\uc785 { Node * y = NIL ; Node * x = ROOT ; while ( x != NIL ) { y = x ; if ( z -> key < x -> key ) { x = x -> left_small ; } else { x = x -> right_large ; } } z -> parent = y ; if ( y == NIL ) { ROOT = z ; } else if ( z -> key < y -> key ) { y -> left_small = z ; } else { y -> right_large = z ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 void BST :: TRANSPLANT ( Node * u , Node * v ) { if ( u -> parent == NIL ) { ROOT = v ; } else if ( u == u -> parent -> left_small ) { u -> parent -> left_small = v ; } else { u -> parent -> right_large = v ; } if ( v != NIL ) { v -> parent = u -> parent ; } } void BST :: TREE_DELETE ( Node * z ) { if ( z -> left_small == NIL ) { TRANSPLANT ( z , z -> right_large ); } else if ( z -> right_large == NIL ) { TRANSPLANT ( z , z -> left_small ); } else { Node * y = TREE_MINIMUM ( z -> right_large ); if ( y -> parent != z ) { TRANSPLANT ( y , y -> right_large ); y -> right_large = z -> right_large ; y -> right_large -> parent = y ; } TRANSPLANT ( z , y ); y -> left_small = z -> left_small ; y -> left_small -> parent = y ; } delete z ; }","title":"12 Binary Search Trees"},{"location":"ch12/readme/#121-what-is-a-binary-search-tree","text":"1 2 3 4 5 6 7 struct Node { Node * right_large ; // key >= int key ; Node * left_small ; // key < Node * parent ; }; 1 2 3 4 5 6 7 8 9 void BST :: INORDER_TREE_WALK ( Node * x ) { if ( x != NIL ) { INORDER_TREE_WALK ( x -> left_small ); std :: cout << x -> key << ' ' ; INORDER_TREE_WALK ( x -> right_large ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 void BST :: preorder () //\uc804\uc704\uc21c\ud68c { if ( ROOT == NIL ) return ; preorder_procedure ( ROOT ); std :: cout << '\\n' ; } void BST :: Inorder () //\uc911\uc704\uc21c\ud68c { if ( ROOT == NIL ) return ; inorder_procedure ( ROOT ); std :: cout << '\\n' ; } void BST :: postorder () //\ud6c4\uc704\uc21c\ud68c { if ( ROOT == NIL ) return ; postorder_procedure ( ROOT ); std :: cout << '\\n' ; } void BST :: inorder_procedure ( Node * _node ) { if ( _node -> left_small != NIL ) inorder_procedure ( _node -> left_small ); std :: cout << _node -> key << \" \" ; if ( _node -> right_large != NIL ) inorder_procedure ( _node -> right_large ); } /* 1.\ub178\ub4dc\ub97c \ubc29\ubb38\ud55c\ub2e4. 2.\uc67c\ucabd \uc11c\ube0c \ud2b8\ub9ac\ub97c \uc911\uc704 \uc21c\ud68c\ud55c\ub2e4. 3.\uc624\ub978\ucabd \uc11c\ube0c \ud2b8\ub9ac\ub97c \uc911\uc704 \uc21c\ud68c\ud55c\ub2e4. */ void BST :: preorder_procedure ( Node * _node ) { std :: cout << _node -> key << \" \" ; if ( _node -> left_small != NIL ) preorder_procedure ( _node -> left_small ); if ( _node -> right_large != NIL ) preorder_procedure ( _node -> right_large ); } /* \uc67c\ucabd \uc11c\ube0c \ud2b8\ub9ac\ub97c \ud6c4\uc704 \uc21c\ud68c\ud55c\ub2e4. \uc624\ub978\ucabd \uc11c\ube0c \ud2b8\ub9ac\ub97c \ud6c4\uc704 \uc21c\ud68c\ud55c\ub2e4. \ub178\ub4dc\ub97c \ubc29\ubb38\ud55c\ub2e4. */ void BST :: postorder_procedure ( Node * _node ) { if ( _node -> left_small != NIL ) postorder_procedure ( _node -> left_small ); if ( _node -> right_large != NIL ) postorder_procedure ( _node -> right_large ); std :: cout << _node -> key << \" \" ; } //recursion -> while","title":"12.1 What is a binary search tree?"},{"location":"ch12/readme/#122-querying-a-binary-search-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Node * BST :: TREE_SEARCH ( Node * x , int k ) { if ( x == NIL || k == x -> key ) { return x ; } if ( k < x -> key ) { return TREE_SEARCH ( x -> left_small , k ); } else { return TREE_SEARCH ( x -> right_large , k ); } } 1 2 3 4 5 6 7 8 9 10 11 12 Node * BST :: ITERATIVE_TREE_SEARCH ( Node * x , int k ) { while ( x != NIL && k != x -> key ) { if ( k < x -> key ) { x = x -> left_small ; } else x = x -> right_large ; } return x ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Node * BST :: TREE_MINIMUM ( Node * x ) // \uc11c\ube0c\ud2b8\ub9ac\uc758 \ucd5c\uc19f\uac12 \ubc18\ud658 { while ( x -> left_small != NIL ) { x = x -> left_small ; } return x ; } Node * BST :: TREE_MAXIMUM ( Node * x ) // \uc11c\ube0c\ud2b8\ub9ac\uc758 \ucd5c\ub313\uac12 \ubc18\ud658 { while ( x -> right_large != NIL ) { x = x -> right_large ; } return x ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Node * BST :: TREE_SUCCESSOR ( Node * x ) // \uc9c1\ud6c4\ub178\ub4dc { if ( x -> right_large != NIL ) { return TREE_MINIMUM ( x -> right_large ); } Node * y = x -> parent ; while ( y != NIL && x == y -> right_large ) //\ub8e8\ud2b8\uac00\uc544\ub2c8\uace0 \uc624\ub978\ucabd\ub178\ub4dc\uc774\uba74 { x = y ; y = y -> parent ; } return y ; } //12.2-3 Node * BST :: TREE_PREDECESSOR ( Node * x ) //\uc9c1\uc804\ub178\ub4dc { if ( x -> left_small != NIL ) { return TREE_MAXIMUM ( x -> left_small ); } Node * y = x -> parent ; while ( y != NIL && x == y -> left_small ) //\ub8e8\ud2b8\uac00\uc544\ub2c8\uace0 \uc624\ub978\ucabd\ub178\ub4dc\uc774\uba74 { x = y ; y = y -> parent ; } return y ; }","title":"12.2 Querying a binary search tree"},{"location":"ch12/readme/#123-insertion-and-deletion","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void BST :: TREE_INSERT ( Node * z ) // \ucc45\uc5d0 \ub098\uc624\ub294 \uc0bd\uc785 { Node * y = NIL ; Node * x = ROOT ; while ( x != NIL ) { y = x ; if ( z -> key < x -> key ) { x = x -> left_small ; } else { x = x -> right_large ; } } z -> parent = y ; if ( y == NIL ) { ROOT = z ; } else if ( z -> key < y -> key ) { y -> left_small = z ; } else { y -> right_large = z ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 void BST :: TRANSPLANT ( Node * u , Node * v ) { if ( u -> parent == NIL ) { ROOT = v ; } else if ( u == u -> parent -> left_small ) { u -> parent -> left_small = v ; } else { u -> parent -> right_large = v ; } if ( v != NIL ) { v -> parent = u -> parent ; } } void BST :: TREE_DELETE ( Node * z ) { if ( z -> left_small == NIL ) { TRANSPLANT ( z , z -> right_large ); } else if ( z -> right_large == NIL ) { TRANSPLANT ( z , z -> left_small ); } else { Node * y = TREE_MINIMUM ( z -> right_large ); if ( y -> parent != z ) { TRANSPLANT ( y , y -> right_large ); y -> right_large = z -> right_large ; y -> right_large -> parent = y ; } TRANSPLANT ( z , y ); y -> left_small = z -> left_small ; y -> left_small -> parent = y ; } delete z ; }","title":"12.3 Insertion and deletion"},{"location":"ch13/REDBLACKTREE/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 enum RBcolor { RED = 0 , BLACK = 1 }; struct RBNode { RBNode * right_large ; // key >= int key ; RBNode * left_small ; // key < RBNode * parent ; RBcolor color ; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 RBT (); RBT ( int n ); ~ RBT (); RBNode * TREE_MINIMUM ( RBNode * _node ); RBNode * TREE_MAXIMUM ( RBNode * _node ); RBNode * TREE_SUCCESSOR ( RBNode * _node ); RBNode * TREE_PREDECESSOR ( RBNode * _node ); void preorder (); void Inorder (); void postorder (); void RB_INSERT ( RBNode * z ); void RB_DELETE ( RBNode * z ); void LEFT_ROTATE ( RBNode * _node ); void RIGHT_ROTATE ( RBNode * _node ); RBNode * ROOT ; RBNode * NIL ; void inorder_procedure ( RBNode * _node ); void preorder_procedure ( RBNode * _node ); void postorder_procedure ( RBNode * _node ); void delete_node ( RBNode * _node ); void RB_TRANSPLANT ( RBNode * u , RBNode * v ); void RB_INSERT_FIXUP ( RBNode * z ); void RB_DELETE_FIXUP ( RBNode * x ); 1 RBT(int n); n\uc744 \ud0a4\ub85c\uac00\uc9c0\ub294 \ub8e8\ud2b8\ub85c \ud2b8\ub9ac\ub97c \uc0dd\uc131 1 ~RBT(); \ub3d9\uc801\ud560\ub2f9 \ud574\uc81c 1 2 3 4 5 6 7 8 9 void RB_TRANSPLANT ( RBNode * u , RBNode * v ); void RB_INSERT ( RBNode * z ); void RB_DELETE ( RBNode * z ); void RB_INSERT_FIXUP ( RBNode * z ); void RB_DELETE_FIXUP ( RBNode * x ); \ub178\ub4dc\ub300\uccb4 \uc0bd\uc785 \uc0ad\uc81c , \uc0c9\uae54\ub9de\ucd94\ub294 \ub0b4\ubd80 \ud504\ub85c\uc2dc\uc838","title":"REDBLACKTREE"},{"location":"ch15/readme/","text":"Characterize the structure of an optimal solution Recursively define the value of an optimal solution Compute the calue of an optimal solution, typically in a bottom-up fashion Construct an optimal solution from computed information 15.1 ROD CUTING 1 std :: vector < int > p = { 0 , 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 , 24 , 30 }; \uc644\uc804 \ud0d0\uc0c9 $O(2^n)$ 1 2 3 4 5 6 7 8 9 10 11 12 nt CUT_ROD ( int p [], int n ) // p\ub294 index 1\ubd80\ud130 \uc800\uc7a5\ub418\uc5b4\uc788\ub2e4. { if ( n == 0 ) { return 0 ; } int q = INT32_MIN ; for ( int i = 1 ; i <= n ; i ++ ) { q = std :: max ( q , p [ i - 1 ] + CUT_ROD ( p , n - i )); } } \uba54\ubaa8\uc774\uc81c\uc774\uc158 \ubc29\ubc95 (top-down with memoization) $O(n^2)$ 1 2 3 4 5 6 7 8 9 10 11 int MEMOIZED_CUT_ROD ( int p [], int n ) { int * r = new int [ n + 1 ]; for ( int i = 0 ; i <= n ; ++ i ) { r [ i ] = INT32_MIN ; } int q = MEMOIZED_CUT_ROD_AUX ( p , n , r ); delete [] r ; return q ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int MEMOIZED_CUT_ROD_AUX ( int p [], int n , int r []) { int q ; if ( r [ n ] >= 0 ) { return r [ n ]; } if ( n == 0 ) { q = 0 ; } else { q = INT32_MIN ; for ( int i = 1 ; i <= n ; ++ i ) { q = std :: max ( q , p [ i ] + MEMOIZED_CUT_ROD_AUX ( p , n - i , r )); } } r [ n ] = q ; return q ; } bottm-up method(\ubc84\ud2bc\uc5c5 /\uc0c1\ud5a5\uc2dd) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int BOTTOM_UP_CUT_ROD ( int p [], int n ) { int * r = new int [ n + 1 ]; r [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { int q = INT32_MIN ; for ( int i = 1 ; i <= j ; i ++ ) { q = std :: max ( q , p [ i ] + r [ j - i ]); } r [ j ] = q ; } delete [] r ; return r [ n ]; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 std :: vector < std :: vector < int >> EXTENDED_BOTTOM_UP_CUT_ROD ( int p [], int n ) { const int INF = 10000000 ; std :: vector < std :: vector < int >> rs ; // r, s rs . resize ( 2 ); rs [ 0 ]. resize ( n + 1 ); rs [ 1 ]. resize ( n + 1 ); rs [ 0 ][ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { int q = - INF ; for ( int i = 1 ; i <= j ; i ++ ) { if ( q < p [ i ] + rs [ 0 ][ j - i ]) { q = p [ i ] + rs [ 0 ][ j - i ]; rs [ 1 ][ j ] = i ; } } rs [ 0 ][ j ] = q ; } return rs ; } void PRINT_CUT_ROD_COLUTION ( int p [], int n ) { std :: vector < std :: vector < int >> rs = EXTENDED_BOTTOM_UP_CUT_ROD ( p , n ); while ( n > 0 ) { std :: cout << rs [ 1 ][ n ] << ' ' ; n = n - rs [ 1 ][ n ]; } std :: cout << std :: endl ; } 15.2 Matrix_chain_multiplication https://www.acmicpc.net/problem/11049 1 typedef std :: pair < std :: vector < std :: vector < int >> , std :: vector < std :: vector < int >>> Set ; $O(n^3)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Set MATRIX_CHAIN_ORDER ( const std :: vector < int > & p ) { const int INF = 1000000000 ; const int n = p . size () - 1 ; std :: vector < std :: vector < int >> m ( n + 1 , std :: vector < int > ( n + 1 , 0 )); std :: vector < std :: vector < int >> s ( n + 1 , std :: vector < int > ( n + 1 , 0 )); for ( int l = 2 ; l <= n ; l ++ ) { for ( int i = 1 ; i <= n - l + 1 ; i ++ ) { int j = i + l - 1 ; m [ i ][ j ] = INF ; for ( int k = i ; k <= j - 1 ; k ++ ) { int q = m [ i ][ k ] + m [ k + 1 ][ j ] + p [ i - 1 ] * p [ k ] * p [ j ]; if ( q < m [ i ][ j ]) { m [ i ][ j ] = q ; s [ i ][ j ] = k ; } } } } return std :: make_pair ( m , s ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void PRINT_OPTIMAL_PARENS ( const std :: vector < std :: vector < int >> & s , int i , int j ) { if ( i == j ) { std :: cout << \"A\" << i ; } else { std :: cout << '(' ; PRINT_OPTIMAL_PARENS ( s , i , s [ i ][ j ]); PRINT_OPTIMAL_PARENS ( s , s [ i ][ j ] + 1 , j ); std :: cout << ')' ; } } 15.3 Elements of dynamic programming 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int RECURSIVE_MATRIX_CHAIN ( const std :: vector < int > & p , int i , int j ) { const int INF = 1000000000 ; const int n = p . size () - 1 ; std :: vector < std :: vector < int >> m ( n + 1 , std :: vector < int > ( n + 1 , 0 )); if ( i == j ) { return 0 ; } m [ i ][ j ] = INF ; for ( int k = i ; k <= j - 1 ; k ++ ) { int q = RECURSIVE_MATRIX_CHAIN ( p , i , k ) + RECURSIVE_MATRIX_CHAIN ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ]; if ( q < m [ i ][ j ]) { m [ i ][ j ] = q ; } } return m [ i ][ j ]; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 int LOOKUP_CHAIN ( std :: vector < std :: vector < int >> & m , const std :: vector < int > & p , int i , int j ) { const int INF = 1000000000 ; if ( m [ i ][ j ] < INF ) { return m [ i ][ j ]; } if ( i == j ) { m [ i ][ j ] = 0 ; } else for ( int k = i ; k <= j - 1 ; k ++ ) { int q = LOOKUP_CHAIN ( m , p , i , k ) + LOOKUP_CHAIN ( m , p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ]; if ( q < m [ i ][ j ]) { m [ i ][ j ] = q ; } } return m [ i ][ j ]; } int MEMORIZED_MATRIX_CHAIN ( const std :: vector < int > & p ) { const int INF = 1000000000 ; const int n = p . size () - 1 ; std :: vector < std :: vector < int >> m ( n + 1 , std :: vector < int > ( n + 1 , 0 )); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { m [ i ][ j ] = INF ; } } return LOOKUP_CHAIN ( m , p , 1 , n ); } 15.4 Longest common subsequence \ucc38\uace0 : https://www.acmicpc.net/problem/9251 https://www.acmicpc.net/problem/9252 $O(mn)$ 1 2 3 4 5 const char * X = \"ABCBDAB\" ; const char * Y = \"BDCABA\" ; const char * X = \"ACCGGTCGAGTGCGCGGAAGCCGGCCGAA\" ; const char * Y = \"GTCGTTCGGAATGCCGTTGCTCTGTAAA\" ; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include <string.h> enum class arrow { left_up , up , left }; typedef std :: pair < std :: vector < std :: vector < int >> , std :: vector < std :: vector < arrow >>> Set ; Set LCS_LENGTH ( const char * XX , const char * YY , const int m , const int n ) { const char * X = XX - 1 ; const char * Y = YY - 1 ; std :: vector < std :: vector < arrow >> b ( m + 1 , std :: vector < arrow > ( n + 1 , arrow :: left_up )) ; std :: vector < std :: vector < int >> c ( m + 1 , std :: vector < int > ( n + 1 , 0 )) ; for ( int i = 1 ; i <= m ; i ++ ) { c [ i ][ 0 ] = 0 ; } for ( int j = 0 ; j <= n ; j ++ ) { c [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( X [ i ] == Y [ j ]) { c [ i ][ j ] = c [ i - 1 ][ j - 1 ] + 1 ; b [ i ][ j ] = arrow :: left_up ; } else if ( c [ i - 1 ][ j ] >= c [ i ][ j - 1 ]) { c [ i ][ j ] = c [ i - 1 ][ j ]; b [ i ][ j ] = arrow :: up ; } else { c [ i ][ j ] = c [ i ][ j - 1 ]; b [ i ][ j ] = arrow :: left ; } } } return std :: make_pair ( c , b ); } void PRINT_LCS ( const std :: vector < std :: vector < arrow >> b , const char * XX , int i , int j ) { const char * X = XX - 1 ; if ( i == 0 || j == 0 ) { return ; } if ( b [ i ][ j ] == arrow :: left_up ) { PRINT_LCS ( b , X + 1 , i - 1 , j - 1 ); std :: cout << X [ i ] << ' ' ; } else if ( b [ i ][ j ] == arrow :: up ) { PRINT_LCS ( b , X + 1 , i - 1 , j ); } else PRINT_LCS ( b , X + 1 , i , j - 1 ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 int table [ 1001 ][ 1001 ] ; char arr [ 1002 ] ; char brr [ 1002 ] ; const int asize = strlen ( arr ); const int bsize = strlen ( brr ); for ( int i = 1 ; i < asize + 1 ; i ++ ) { for ( int j = 1 ; j < bsize + 1 ; j ++ ) { if ( arr [ i - 1 ] == brr [ j - 1 ] ) { table [ i ][ j ] = table [ i - 1 ][ j - 1 ] + 1 ; } else if ( table [ i - 1 ][ j ] > table [ i ][ j - 1 ] ) { table [ i ][ j ] = table [ i - 1 ][ j ] ; } else { table [ i ][ j ] = table [ i ][ j - 1 ] ; } } } stack < char > stk ; int i = asize , j = bsize ; while ( ! ( j == 0 || i == 0 )) { if ( arr [ i-1 ] == brr [ j-1 ] ) { i --; j--; stk . push ( arr [ i ] ); } else if ( table [ i-1 ][ j ] >= table [ i ][ j-1 ] ) { i --; } else { j --; } } while ( ! stk . empty ()) { cout << stk . top (); stk . pop (); } table[asize][bsize] stk https://www.acmicpc.net/problem/9252 15.5 Optimal binary search trees","title":"15 Dynamic Programming"},{"location":"ch15/readme/#151-rod-cuting","text":"1 std :: vector < int > p = { 0 , 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 , 24 , 30 }; \uc644\uc804 \ud0d0\uc0c9 $O(2^n)$ 1 2 3 4 5 6 7 8 9 10 11 12 nt CUT_ROD ( int p [], int n ) // p\ub294 index 1\ubd80\ud130 \uc800\uc7a5\ub418\uc5b4\uc788\ub2e4. { if ( n == 0 ) { return 0 ; } int q = INT32_MIN ; for ( int i = 1 ; i <= n ; i ++ ) { q = std :: max ( q , p [ i - 1 ] + CUT_ROD ( p , n - i )); } } \uba54\ubaa8\uc774\uc81c\uc774\uc158 \ubc29\ubc95 (top-down with memoization) $O(n^2)$ 1 2 3 4 5 6 7 8 9 10 11 int MEMOIZED_CUT_ROD ( int p [], int n ) { int * r = new int [ n + 1 ]; for ( int i = 0 ; i <= n ; ++ i ) { r [ i ] = INT32_MIN ; } int q = MEMOIZED_CUT_ROD_AUX ( p , n , r ); delete [] r ; return q ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int MEMOIZED_CUT_ROD_AUX ( int p [], int n , int r []) { int q ; if ( r [ n ] >= 0 ) { return r [ n ]; } if ( n == 0 ) { q = 0 ; } else { q = INT32_MIN ; for ( int i = 1 ; i <= n ; ++ i ) { q = std :: max ( q , p [ i ] + MEMOIZED_CUT_ROD_AUX ( p , n - i , r )); } } r [ n ] = q ; return q ; } bottm-up method(\ubc84\ud2bc\uc5c5 /\uc0c1\ud5a5\uc2dd) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int BOTTOM_UP_CUT_ROD ( int p [], int n ) { int * r = new int [ n + 1 ]; r [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { int q = INT32_MIN ; for ( int i = 1 ; i <= j ; i ++ ) { q = std :: max ( q , p [ i ] + r [ j - i ]); } r [ j ] = q ; } delete [] r ; return r [ n ]; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 std :: vector < std :: vector < int >> EXTENDED_BOTTOM_UP_CUT_ROD ( int p [], int n ) { const int INF = 10000000 ; std :: vector < std :: vector < int >> rs ; // r, s rs . resize ( 2 ); rs [ 0 ]. resize ( n + 1 ); rs [ 1 ]. resize ( n + 1 ); rs [ 0 ][ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { int q = - INF ; for ( int i = 1 ; i <= j ; i ++ ) { if ( q < p [ i ] + rs [ 0 ][ j - i ]) { q = p [ i ] + rs [ 0 ][ j - i ]; rs [ 1 ][ j ] = i ; } } rs [ 0 ][ j ] = q ; } return rs ; } void PRINT_CUT_ROD_COLUTION ( int p [], int n ) { std :: vector < std :: vector < int >> rs = EXTENDED_BOTTOM_UP_CUT_ROD ( p , n ); while ( n > 0 ) { std :: cout << rs [ 1 ][ n ] << ' ' ; n = n - rs [ 1 ][ n ]; } std :: cout << std :: endl ; }","title":"15.1 ROD CUTING"},{"location":"ch15/readme/#152-matrix_chain_multiplication","text":"https://www.acmicpc.net/problem/11049 1 typedef std :: pair < std :: vector < std :: vector < int >> , std :: vector < std :: vector < int >>> Set ; $O(n^3)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Set MATRIX_CHAIN_ORDER ( const std :: vector < int > & p ) { const int INF = 1000000000 ; const int n = p . size () - 1 ; std :: vector < std :: vector < int >> m ( n + 1 , std :: vector < int > ( n + 1 , 0 )); std :: vector < std :: vector < int >> s ( n + 1 , std :: vector < int > ( n + 1 , 0 )); for ( int l = 2 ; l <= n ; l ++ ) { for ( int i = 1 ; i <= n - l + 1 ; i ++ ) { int j = i + l - 1 ; m [ i ][ j ] = INF ; for ( int k = i ; k <= j - 1 ; k ++ ) { int q = m [ i ][ k ] + m [ k + 1 ][ j ] + p [ i - 1 ] * p [ k ] * p [ j ]; if ( q < m [ i ][ j ]) { m [ i ][ j ] = q ; s [ i ][ j ] = k ; } } } } return std :: make_pair ( m , s ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void PRINT_OPTIMAL_PARENS ( const std :: vector < std :: vector < int >> & s , int i , int j ) { if ( i == j ) { std :: cout << \"A\" << i ; } else { std :: cout << '(' ; PRINT_OPTIMAL_PARENS ( s , i , s [ i ][ j ]); PRINT_OPTIMAL_PARENS ( s , s [ i ][ j ] + 1 , j ); std :: cout << ')' ; } }","title":"15.2 Matrix_chain_multiplication"},{"location":"ch15/readme/#153-elements-of-dynamic-programming","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int RECURSIVE_MATRIX_CHAIN ( const std :: vector < int > & p , int i , int j ) { const int INF = 1000000000 ; const int n = p . size () - 1 ; std :: vector < std :: vector < int >> m ( n + 1 , std :: vector < int > ( n + 1 , 0 )); if ( i == j ) { return 0 ; } m [ i ][ j ] = INF ; for ( int k = i ; k <= j - 1 ; k ++ ) { int q = RECURSIVE_MATRIX_CHAIN ( p , i , k ) + RECURSIVE_MATRIX_CHAIN ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ]; if ( q < m [ i ][ j ]) { m [ i ][ j ] = q ; } } return m [ i ][ j ]; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 int LOOKUP_CHAIN ( std :: vector < std :: vector < int >> & m , const std :: vector < int > & p , int i , int j ) { const int INF = 1000000000 ; if ( m [ i ][ j ] < INF ) { return m [ i ][ j ]; } if ( i == j ) { m [ i ][ j ] = 0 ; } else for ( int k = i ; k <= j - 1 ; k ++ ) { int q = LOOKUP_CHAIN ( m , p , i , k ) + LOOKUP_CHAIN ( m , p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ]; if ( q < m [ i ][ j ]) { m [ i ][ j ] = q ; } } return m [ i ][ j ]; } int MEMORIZED_MATRIX_CHAIN ( const std :: vector < int > & p ) { const int INF = 1000000000 ; const int n = p . size () - 1 ; std :: vector < std :: vector < int >> m ( n + 1 , std :: vector < int > ( n + 1 , 0 )); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { m [ i ][ j ] = INF ; } } return LOOKUP_CHAIN ( m , p , 1 , n ); }","title":"15.3 Elements of dynamic programming"},{"location":"ch15/readme/#154-longest-common-subsequence","text":"\ucc38\uace0 : https://www.acmicpc.net/problem/9251 https://www.acmicpc.net/problem/9252 $O(mn)$ 1 2 3 4 5 const char * X = \"ABCBDAB\" ; const char * Y = \"BDCABA\" ; const char * X = \"ACCGGTCGAGTGCGCGGAAGCCGGCCGAA\" ; const char * Y = \"GTCGTTCGGAATGCCGTTGCTCTGTAAA\" ; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include <string.h> enum class arrow { left_up , up , left }; typedef std :: pair < std :: vector < std :: vector < int >> , std :: vector < std :: vector < arrow >>> Set ; Set LCS_LENGTH ( const char * XX , const char * YY , const int m , const int n ) { const char * X = XX - 1 ; const char * Y = YY - 1 ; std :: vector < std :: vector < arrow >> b ( m + 1 , std :: vector < arrow > ( n + 1 , arrow :: left_up )) ; std :: vector < std :: vector < int >> c ( m + 1 , std :: vector < int > ( n + 1 , 0 )) ; for ( int i = 1 ; i <= m ; i ++ ) { c [ i ][ 0 ] = 0 ; } for ( int j = 0 ; j <= n ; j ++ ) { c [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( X [ i ] == Y [ j ]) { c [ i ][ j ] = c [ i - 1 ][ j - 1 ] + 1 ; b [ i ][ j ] = arrow :: left_up ; } else if ( c [ i - 1 ][ j ] >= c [ i ][ j - 1 ]) { c [ i ][ j ] = c [ i - 1 ][ j ]; b [ i ][ j ] = arrow :: up ; } else { c [ i ][ j ] = c [ i ][ j - 1 ]; b [ i ][ j ] = arrow :: left ; } } } return std :: make_pair ( c , b ); } void PRINT_LCS ( const std :: vector < std :: vector < arrow >> b , const char * XX , int i , int j ) { const char * X = XX - 1 ; if ( i == 0 || j == 0 ) { return ; } if ( b [ i ][ j ] == arrow :: left_up ) { PRINT_LCS ( b , X + 1 , i - 1 , j - 1 ); std :: cout << X [ i ] << ' ' ; } else if ( b [ i ][ j ] == arrow :: up ) { PRINT_LCS ( b , X + 1 , i - 1 , j ); } else PRINT_LCS ( b , X + 1 , i , j - 1 ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 int table [ 1001 ][ 1001 ] ; char arr [ 1002 ] ; char brr [ 1002 ] ; const int asize = strlen ( arr ); const int bsize = strlen ( brr ); for ( int i = 1 ; i < asize + 1 ; i ++ ) { for ( int j = 1 ; j < bsize + 1 ; j ++ ) { if ( arr [ i - 1 ] == brr [ j - 1 ] ) { table [ i ][ j ] = table [ i - 1 ][ j - 1 ] + 1 ; } else if ( table [ i - 1 ][ j ] > table [ i ][ j - 1 ] ) { table [ i ][ j ] = table [ i - 1 ][ j ] ; } else { table [ i ][ j ] = table [ i ][ j - 1 ] ; } } } stack < char > stk ; int i = asize , j = bsize ; while ( ! ( j == 0 || i == 0 )) { if ( arr [ i-1 ] == brr [ j-1 ] ) { i --; j--; stk . push ( arr [ i ] ); } else if ( table [ i-1 ][ j ] >= table [ i ][ j-1 ] ) { i --; } else { j --; } } while ( ! stk . empty ()) { cout << stk . top (); stk . pop (); } table[asize][bsize] stk https://www.acmicpc.net/problem/9252","title":"15.4 Longest common subsequence"},{"location":"ch15/readme/#155-optimal-binary-search-trees","text":"","title":"15.5 Optimal binary search trees"},{"location":"ch16/readme/","text":"16.1\ud65c\ub3d9 \uc120\ud0dd \ubb38\uc81c(activity selection problem) f\uac00 \uc81c\uc77c\uc791\uc740 f[0]\uc744 \uc120\ud0dd\ud55c\ub2e4. \uc774\uac8c a0 \uc774 \uc55e\uc758 f[0]\ubcf4\ub2e4 \ud070 s[i]\ub97c \uc120\ud0dd\ud55c\ub2e4. a1 \ubc18\ubcf5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void RECURSIVE_ACTIVITY_SELECTOR ( int s [], int f [], int k , int n , std :: vector < int > & a ) { int m = k + 1 ; while ( m < n && s [ m ] < f [ k ]) { m = m + 1 ; } if ( m < n ) { a . push_back ( m ); RECURSIVE_ACTIVITY_SELECTOR ( s , f , m , n , a ); } return ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 std :: vector < int > GREEDY_ACTIVITY_SELECTOR ( int s [], int f [], int n ) { std :: vector < int > A ; A . push_back ( 1 ); int k = 1 ; for ( int m = 2 ; m <= n ; m ++ ) { if ( s [ m ] >= f [ k ]) { A . push_back ( m ); k = m ; } } return A ; } 16.2 Elements of the greedy strategy 16.3 Huffman codes","title":"16 Greedy Algorithms"},{"location":"ch16/readme/#161-activity-selection-problem","text":"f\uac00 \uc81c\uc77c\uc791\uc740 f[0]\uc744 \uc120\ud0dd\ud55c\ub2e4. \uc774\uac8c a0 \uc774 \uc55e\uc758 f[0]\ubcf4\ub2e4 \ud070 s[i]\ub97c \uc120\ud0dd\ud55c\ub2e4. a1 \ubc18\ubcf5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void RECURSIVE_ACTIVITY_SELECTOR ( int s [], int f [], int k , int n , std :: vector < int > & a ) { int m = k + 1 ; while ( m < n && s [ m ] < f [ k ]) { m = m + 1 ; } if ( m < n ) { a . push_back ( m ); RECURSIVE_ACTIVITY_SELECTOR ( s , f , m , n , a ); } return ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 std :: vector < int > GREEDY_ACTIVITY_SELECTOR ( int s [], int f [], int n ) { std :: vector < int > A ; A . push_back ( 1 ); int k = 1 ; for ( int m = 2 ; m <= n ; m ++ ) { if ( s [ m ] >= f [ k ]) { A . push_back ( m ); k = m ; } } return A ; }","title":"16.1\ud65c\ub3d9 \uc120\ud0dd \ubb38\uc81c(activity selection problem)"},{"location":"ch16/readme/#162-elements-of-the-greedy-strategy","text":"","title":"16.2 Elements of the greedy strategy"},{"location":"ch16/readme/#163-huffman-codes","text":"","title":"16.3 Huffman codes"},{"location":"ch21/readme/","text":"21.1 Disjoint-set operations \uc811\uadfc\uc131\uc744 \uc704\ud574\uc11c \uc2e4\uc81c \ud2b8\ub9ac \ub300\uc2e0 \ubc30\uc5f4\uc744 \uc0ac\uc6a9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 UNION_FIND CONNECTED_COMPONENTS ( std :: vector < std :: vector < int >> & G ) { const int n = G . size () - 1 ; UNION_FIND set ; for ( int v = 1 ; v <= n ; v ++ ) { set . MAKE_SET ( v ); } for ( int u = 1 ; u <= n ; u ++ ) { const int sub_n = G [ u ]. size (); for ( int i = 0 ; i < sub_n ; i ++ ) { int v = G [ u ][ i ]; if ( set . FIND_SET ( u ) == set . FIND_SET ( v )) { set . UNION ( u , v ); } } } return set ; } bool SAME_COMPONENT ( UNION_FIND set , int u , int v ) { if ( set . FIND_SET ( u ) == set . FIND_SET ( v )) { return true ; } else return false ; } 21.3 Disjoint-set forests 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 //with Disjoint-set forests class UNION_FIND { public : UNION_FIND () { rank = new int ( 101 ); parent = new int ( 101 ); n = 101 ; } UNION_FIND ( int n ) : n ( n ) { rank = new int ( n ); parent = new int ( n ); } void MAKE_SET ( int x ) { parent [ x ] = x ; rank [ x ] = 0 ; } void UNION ( int x , int y ) { LINK ( this -> FIND_SET ( x ), this -> FIND_SET ( y )); } int FIND_SET ( int x ) //path compression { if ( x != parent [ x ]) { parent [ x ] = this -> FIND_SET [ parent [ x ]]; } return parent [ x ]; } int capacity () { return n ; } private : int * rank ; //Union by rank int * parent ; int n ; void LINK ( int x , int y ) { if ( rank [ x ] > rank [ y ]) { parent [ y ] = x ; } else { parent [ x ] = y ; if ( rank [ x ] == rank [ y ]) { rank [ y ] = rank [ y ] + 1 ; } } } };","title":"21 Data Structures for Disjoint Sets"},{"location":"ch21/readme/#211-disjoint-set-operations","text":"\uc811\uadfc\uc131\uc744 \uc704\ud574\uc11c \uc2e4\uc81c \ud2b8\ub9ac \ub300\uc2e0 \ubc30\uc5f4\uc744 \uc0ac\uc6a9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 UNION_FIND CONNECTED_COMPONENTS ( std :: vector < std :: vector < int >> & G ) { const int n = G . size () - 1 ; UNION_FIND set ; for ( int v = 1 ; v <= n ; v ++ ) { set . MAKE_SET ( v ); } for ( int u = 1 ; u <= n ; u ++ ) { const int sub_n = G [ u ]. size (); for ( int i = 0 ; i < sub_n ; i ++ ) { int v = G [ u ][ i ]; if ( set . FIND_SET ( u ) == set . FIND_SET ( v )) { set . UNION ( u , v ); } } } return set ; } bool SAME_COMPONENT ( UNION_FIND set , int u , int v ) { if ( set . FIND_SET ( u ) == set . FIND_SET ( v )) { return true ; } else return false ; }","title":"21.1 Disjoint-set operations"},{"location":"ch21/readme/#213-disjoint-set-forests","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 //with Disjoint-set forests class UNION_FIND { public : UNION_FIND () { rank = new int ( 101 ); parent = new int ( 101 ); n = 101 ; } UNION_FIND ( int n ) : n ( n ) { rank = new int ( n ); parent = new int ( n ); } void MAKE_SET ( int x ) { parent [ x ] = x ; rank [ x ] = 0 ; } void UNION ( int x , int y ) { LINK ( this -> FIND_SET ( x ), this -> FIND_SET ( y )); } int FIND_SET ( int x ) //path compression { if ( x != parent [ x ]) { parent [ x ] = this -> FIND_SET [ parent [ x ]]; } return parent [ x ]; } int capacity () { return n ; } private : int * rank ; //Union by rank int * parent ; int n ; void LINK ( int x , int y ) { if ( rank [ x ] > rank [ y ]) { parent [ y ] = x ; } else { parent [ x ] = y ; if ( rank [ x ] == rank [ y ]) { rank [ y ] = rank [ y ] + 1 ; } } } };","title":"21.3 Disjoint-set forests"},{"location":"ch27/readme/","text":"27.1 The basics of dynamic multithreading 1 2 3 4 5 6 7 8 9 10 11 12 int P_FIB ( int n ) { if ( n <= 1 ) return n ; else { std :: future < int > ret = std :: async ( & P_FIB , n - 1 ); int y = P_FIB ( n - 2 ); int x = ret . get (); return x + y ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void sub_procesure ( std :: vector < int > & y , std :: vector < int > & x , std :: vector < std :: vector < int >> & A , int i ) { for ( int j = 0 ; j < A . size (); j ++ ) { y [ i ] = y [ i ] + A [ i ][ j ] * x [ j ]; } } std :: vector < int > MAT_VEC ( std :: vector < std :: vector < int >> & A , std :: vector < int > & x ) { int n = A [ 0 ]. size (); std :: vector < int > y ( n ); std :: vector < std :: thread > _thread ; for ( int i = 0 ; i < n ; i ++ ) { _thread . push_back ( std :: thread ([] ( std :: vector < int >:: iterator i ) { * i = 0 ; }, y . begin () + i )); } for ( int i = 0 ; i < n ; i ++ ) { _thread [ i ]. join (); } _thread . clear (); for ( int i = 0 ; i < n ; i ++ ) { _thread . push_back ( std :: thread ( sub_procesure , std :: ref ( y ), std :: ref ( x ), std :: ref ( A ), i )); } for ( int i = 0 ; i < n ; i ++ ) { _thread [ i ]. join (); } return y ; } 27.2 Multithreaded matrix multiplication https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm#Parallel_and_distributed_algorithms 27.3 Multithreaded merge sort Not working $S_1 = \\Theta(n\\log n)$ $S_INF = \\Theta(n)$ $parallelism = \\Theta(\\log n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 void MERGE_SORT_PRIME(int A[], int p, int r) { if (p >= r) { return; } int q = (p + r) / 2; std::thread _thread = std::thread(MERGE_SORT_PRIME, A, p, q); MERGE_SORT_PRIME(A, q + 1, r); _thread.join(); MERGE(A, p, q, r); return; } 0~n-1 P_Merge's $S_1 = \\Theta(n)$ $S_INF = \\Theta((\\log n)^2)$ $parallelism = \\Theta(n/(\\log n)^2)$ https://nms.kcl.ac.uk/colin.cooper/teachingmaterial/PAL-PDA/lectures/6B-parallel-MergeSort.pdf 1","title":"27 Multithreaded Algorithms"},{"location":"ch27/readme/#271-the-basics-of-dynamic-multithreading","text":"1 2 3 4 5 6 7 8 9 10 11 12 int P_FIB ( int n ) { if ( n <= 1 ) return n ; else { std :: future < int > ret = std :: async ( & P_FIB , n - 1 ); int y = P_FIB ( n - 2 ); int x = ret . get (); return x + y ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void sub_procesure ( std :: vector < int > & y , std :: vector < int > & x , std :: vector < std :: vector < int >> & A , int i ) { for ( int j = 0 ; j < A . size (); j ++ ) { y [ i ] = y [ i ] + A [ i ][ j ] * x [ j ]; } } std :: vector < int > MAT_VEC ( std :: vector < std :: vector < int >> & A , std :: vector < int > & x ) { int n = A [ 0 ]. size (); std :: vector < int > y ( n ); std :: vector < std :: thread > _thread ; for ( int i = 0 ; i < n ; i ++ ) { _thread . push_back ( std :: thread ([] ( std :: vector < int >:: iterator i ) { * i = 0 ; }, y . begin () + i )); } for ( int i = 0 ; i < n ; i ++ ) { _thread [ i ]. join (); } _thread . clear (); for ( int i = 0 ; i < n ; i ++ ) { _thread . push_back ( std :: thread ( sub_procesure , std :: ref ( y ), std :: ref ( x ), std :: ref ( A ), i )); } for ( int i = 0 ; i < n ; i ++ ) { _thread [ i ]. join (); } return y ; }","title":"27.1 The basics of dynamic multithreading"},{"location":"ch27/readme/#272-multithreaded-matrix-multiplication","text":"https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm#Parallel_and_distributed_algorithms","title":"27.2 Multithreaded matrix multiplication"},{"location":"ch27/readme/#273-multithreaded-merge-sort","text":"Not working $S_1 = \\Theta(n\\log n)$ $S_INF = \\Theta(n)$ $parallelism = \\Theta(\\log n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 void MERGE_SORT_PRIME(int A[], int p, int r) { if (p >= r) { return; } int q = (p + r) / 2; std::thread _thread = std::thread(MERGE_SORT_PRIME, A, p, q); MERGE_SORT_PRIME(A, q + 1, r); _thread.join(); MERGE(A, p, q, r); return; } 0~n-1 P_Merge's $S_1 = \\Theta(n)$ $S_INF = \\Theta((\\log n)^2)$ $parallelism = \\Theta(n/(\\log n)^2)$ https://nms.kcl.ac.uk/colin.cooper/teachingmaterial/PAL-PDA/lectures/6B-parallel-MergeSort.pdf 1","title":"27.3 Multithreaded merge sort"},{"location":"ch28/readme/","text":"28 Matrix Operations I'm setting Matrix index 0 ~ n-1 nxn mat 1 2 typedef std :: vector < std :: vector < double >> Matrix ; typedef std :: pair < std :: vector < std :: vector < double >> , std :: vector < std :: vector < double >>> Set ; 28.1 Solving systems of linear equations $O(n^2)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //n^2 std :: vector < double > LUP_SOLVE ( Matrix & L , Matrix & U , std :: vector < int > & PI , std :: vector < double >& b ) { const int n = L . size (); std :: vector < double > x ( n , 0 ); std :: vector < double > y ( n , 0 ); for ( int i = 0 ; i < n ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j <= i - 1 ; j ++ ) { sum += L [ i ][ j ] * y [ j ]; } y [ i ] = b [ PI [ i ]] - sum ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { double sum = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { sum += U [ i ][ j ] * x [ j ]; } x [ i ] = ( y [ i ] - sum ) / U [ i ][ i ]; } return x ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // n^3 Set LU_DECOMPOSITION ( Matrix & A ) { const int n = A . size (); Matrix L ( n , std :: vector < double > ( n , 0 )); Matrix U ( n , std :: vector < double > ( n , 0 )); for ( int i = 0 ; i < n ; i ++ ) { L [ i ][ i ] = 1 ; } for ( int k = 0 ; k < n ; k ++ ) { U [ k ][ k ] = A [ k ][ k ]; for ( int i = k + 1 ; i < n ; i ++ ) { L [ i ][ k ] = A [ i ][ k ] / U [ k ][ k ]; U [ k ][ i ] = A [ k ][ i ]; } for ( int i = k + 1 ; i < n ; i ++ ) { for ( int j = k + 1 ; j < n ; j ++ ) { A [ i ][ j ] = A [ i ][ j ] - L [ i ][ k ] * U [ k ][ j ]; } } } return std :: make_pair ( L , U ); } figure28.2 ex is wrong ex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 std :: vector < int > LUP_DECOMPOSITION ( Matrix & A ) { const int n = A . size (); std :: vector < int > pi ( n , 0 ); for ( int i = 0 ; i < n ; i ++ ) { pi [ i ] = i ; } for ( int k = 0 ; k < n - 1 ; k ++ ) { int k_prime = - 1 ; double p = 0 ; for ( int i = k ; i < n ; i ++ ) { if ( A [ i ][ k ] > p ) { p = A [ i ][ k ]; k_prime = i ; } } if ( p == 0 ) { std :: cout << \"singular Matrix\" << std :: endl ; } //swap int sub = pi [ k ]; pi [ k ] = pi [ k_prime ]; pi [ k_prime ] = sub ; for ( int i = 0 ; i < n ; i ++ ) { double sub = A [ k ][ i ]; A [ k ][ i ] = A [ k_prime ][ i ]; A [ k_prime ][ i ] = sub ; } for ( int i = k + 1 ; i < n ; i ++ ) { A [ i ][ k ] = A [ i ][ k ] / A [ k ][ k ]; for ( int j = k + 1 ; j < n ; j ++ ) { A [ i ][ j ] = A [ i ][ j ] - A [ i ][ k ] * A [ k ][ j ]; } } } return pi ; }","title":"28 Matrix Operations"},{"location":"ch28/readme/#28-matrix-operations","text":"I'm setting Matrix index 0 ~ n-1 nxn mat 1 2 typedef std :: vector < std :: vector < double >> Matrix ; typedef std :: pair < std :: vector < std :: vector < double >> , std :: vector < std :: vector < double >>> Set ;","title":"28 Matrix Operations"},{"location":"ch28/readme/#281-solving-systems-of-linear-equations","text":"$O(n^2)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //n^2 std :: vector < double > LUP_SOLVE ( Matrix & L , Matrix & U , std :: vector < int > & PI , std :: vector < double >& b ) { const int n = L . size (); std :: vector < double > x ( n , 0 ); std :: vector < double > y ( n , 0 ); for ( int i = 0 ; i < n ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j <= i - 1 ; j ++ ) { sum += L [ i ][ j ] * y [ j ]; } y [ i ] = b [ PI [ i ]] - sum ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { double sum = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { sum += U [ i ][ j ] * x [ j ]; } x [ i ] = ( y [ i ] - sum ) / U [ i ][ i ]; } return x ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // n^3 Set LU_DECOMPOSITION ( Matrix & A ) { const int n = A . size (); Matrix L ( n , std :: vector < double > ( n , 0 )); Matrix U ( n , std :: vector < double > ( n , 0 )); for ( int i = 0 ; i < n ; i ++ ) { L [ i ][ i ] = 1 ; } for ( int k = 0 ; k < n ; k ++ ) { U [ k ][ k ] = A [ k ][ k ]; for ( int i = k + 1 ; i < n ; i ++ ) { L [ i ][ k ] = A [ i ][ k ] / U [ k ][ k ]; U [ k ][ i ] = A [ k ][ i ]; } for ( int i = k + 1 ; i < n ; i ++ ) { for ( int j = k + 1 ; j < n ; j ++ ) { A [ i ][ j ] = A [ i ][ j ] - L [ i ][ k ] * U [ k ][ j ]; } } } return std :: make_pair ( L , U ); } figure28.2 ex is wrong ex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 std :: vector < int > LUP_DECOMPOSITION ( Matrix & A ) { const int n = A . size (); std :: vector < int > pi ( n , 0 ); for ( int i = 0 ; i < n ; i ++ ) { pi [ i ] = i ; } for ( int k = 0 ; k < n - 1 ; k ++ ) { int k_prime = - 1 ; double p = 0 ; for ( int i = k ; i < n ; i ++ ) { if ( A [ i ][ k ] > p ) { p = A [ i ][ k ]; k_prime = i ; } } if ( p == 0 ) { std :: cout << \"singular Matrix\" << std :: endl ; } //swap int sub = pi [ k ]; pi [ k ] = pi [ k_prime ]; pi [ k_prime ] = sub ; for ( int i = 0 ; i < n ; i ++ ) { double sub = A [ k ][ i ]; A [ k ][ i ] = A [ k_prime ][ i ]; A [ k_prime ][ i ] = sub ; } for ( int i = k + 1 ; i < n ; i ++ ) { A [ i ][ k ] = A [ i ][ k ] / A [ k ][ k ]; for ( int j = k + 1 ; j < n ; j ++ ) { A [ i ][ j ] = A [ i ][ j ] - A [ i ][ k ] * A [ k ][ j ]; } } } return pi ; }","title":"28.1 Solving systems of linear equations"},{"location":"ch30/readme/","text":"1 2 3 4 5 6 #include <complex> #include <valarray> constexpr double PI = 3.141592653589793238460 ; typedef std :: complex < double > Complex ; typedef std :: valarray < Complex > CArray ; 30.2 The DFT and FFT DFT \ub97c \uad6c\ud558\uae30\uc704\ud574 FFT\ub97c \uc0ac\uc6a9\ud55c\ub2e4. ref https://rosettacode.org/wiki/Fast_Fourier_transform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 CArray RECURSIVE_FFT ( CArray & a ) { const std :: size_t n = a . size (); if ( n <= 1 ) return a ; //w = cos(x) + i * sin(x) // w_n = e^{(2pi/n)*i } Complex wn = std :: polar ( 1.0 , 2 * PI / n ); Complex w = 1 ; // divide //even CArray a0 = a [ std :: slice ( 0 , n / 2 , 2 )]; //odd CArray a1 = a [ std :: slice ( 1 , n / 2 , 2 )]; // conquer CArray y0 = RECURSIVE_FFT ( a0 ); CArray y1 = RECURSIVE_FFT ( a1 ); CArray y ( Complex ( 0 ), n ); // combine for ( size_t k = 0 ; k < n / 2 ; ++ k ) { y [ k ] = y0 [ k ] + w * y1 [ k ]; y [ k + n / 2 ] = y0 [ k ] - w * y1 [ k ]; w = w * wn ; } return y ; } 1","title":"30 Polynomials and the FFT"},{"location":"ch30/readme/#302-the-dft-and-fft","text":"DFT \ub97c \uad6c\ud558\uae30\uc704\ud574 FFT\ub97c \uc0ac\uc6a9\ud55c\ub2e4. ref https://rosettacode.org/wiki/Fast_Fourier_transform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 CArray RECURSIVE_FFT ( CArray & a ) { const std :: size_t n = a . size (); if ( n <= 1 ) return a ; //w = cos(x) + i * sin(x) // w_n = e^{(2pi/n)*i } Complex wn = std :: polar ( 1.0 , 2 * PI / n ); Complex w = 1 ; // divide //even CArray a0 = a [ std :: slice ( 0 , n / 2 , 2 )]; //odd CArray a1 = a [ std :: slice ( 1 , n / 2 , 2 )]; // conquer CArray y0 = RECURSIVE_FFT ( a0 ); CArray y1 = RECURSIVE_FFT ( a1 ); CArray y ( Complex ( 0 ), n ); // combine for ( size_t k = 0 ; k < n / 2 ; ++ k ) { y [ k ] = y0 [ k ] + w * y1 [ k ]; y [ k + n / 2 ] = y0 [ k ] - w * y1 [ k ]; w = w * wn ; } return y ; } 1","title":"30.2 The DFT and FFT"},{"location":"ch31/readme/","text":"31.2 GCD Euclid's algorithm $O(\\log b)$ 1 2 3 4 5 6 7 int EUCLID ( int a , int b ) { if ( b == 0 ) return a ; else return EUCLID ( b , a % b ); } EXTENDED_EUCLID 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <tuple> std :: tuple < int , int , int > EXTENDED_EUCLID ( int a , int b ) { if ( b == 0 ) { std :: tuple < int , int , int > x ( a , 1 , 0 ); return x ; } std :: tuple < int , int , int > x = EXTENDED_EUCLID ( b , a % b ); //d x y std :: tuple < int , int , int > y = std :: make_tuple ( std :: get < 0 > ( x ), std :: get < 2 > ( x ), std :: get < 1 > ( x ) - ( a / b ) * std :: get < 2 > ( x )); return y ; } 31.4 MODULAR_LINEAR_EQUATION_SOLVER $O(\\log n + \\gcd(a,n))$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void MODULAR_LINEAR_EQUATION_SOLVER ( int a , int b , int n ) //ax = b (mod n) { std :: tuple < int , int , int > set = EXTENDED_EUCLID ( a , n ); int d = std :: get < 0 > ( set ); if ( b / d ) { int x_0 = ((( std :: get < 1 > ( set ) * ( b / d )) % n ) + n ) % n ; //x_0 %= n; for ( int i = 0 ; i <= d - 1 ; i ++ ) { std :: cout << ( x_0 + ( i * ( n / d ))) % n << ' ' ; } } else { std :: cout << \"no solution\" ; } } modulo \uc5f0\uc0b0\uc5d0\ub300\ud55c \uc5ed 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int extended_Euclid_for_multiple_inverse ( const int a , const int mod_n ) { if ( gcd ( a , mod_n ) != 1 ) return - 1 ; r1 = a , r2 = mod_n ; t1 = 0 , t2 = 1 ; u , r , t ; while ( r2 > 0 ) { u = r1 / r2 ; r = r1 % r2 ; r1 = r2 ; r2 = r ; t = t1 - u * t2 ; t1 = t2 ; t2 = t ; } if ( t1 < 0 ) t1 += mod_n ; return t1 ; //e } 31.5 The Chinese remainder theorem https://www.acmicpc.net/problem/1476 31.6 \uace0\uc18d \uac70\ub4ed\uc81c\uacf1 \ubaa8\ub4c8\ub7ec \uc5f0\uc0b0 CLRS\uc5d0 \uc18c\uac1c\ub41c \uc758\uc0ac\ucf54\ub4dc\ub294 \uc798 \uc791\ub3d9\ud558\uc9c0 \uc54a\ub294\ub2e4. \ucf54\ub4dc\ub97c \uc0b4\ud3b4\ubcf4\uba74 c\ub97c \uc0ac\uc6a9\ud558\uc9c0\uc54a\uc74c d - bit $O(d)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int MODULAR_EXPONENTIATION ( int a , int b , int n ) //a^b mod n { int x = a , y = 1 ; while ( b != 0 ) { if ( b & 1 ) { y = ( x * y ) % n ; } x = ( x * x ) % n ; b = b >> 1 ; } return y ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 int EXPONENTIATION ( int a , int b ) //a^b int x = a , y = 1 ; while ( b != 0 ) { if ( b & 1 ) { y = ( x * y ); } x = ( x * x ); b = b >> 1 ; } return y ; } 31.7 The RSA public-key crytosystem Select at random two large prime numbers p and q such that p != q. The primes p and q might be, say, 1024 bits each. Compute n = pq. Select a small odd integer e that is relatively prime to pi(n), which, by equation (31.20), equals (p-1)(q-1) Compute d as the multiplicative inverse of e, modulo pi(n). (Corollary 31.26 guarantees that d exists and is uniquely defined. We can use the technique of Section 31.4 to compute d, given e and pi(n)) Publish the pair P = (e,n) as the participant\u2019s RSA public key. Keep secret the pair S = (d, n) as the participant\u2019s RSA secret key. go to RSA.h 31.8 Primality tetsting $O(\\sqrt{n})$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 bool trial_division ( int n ) { if ( n == 2 ) { return true ; } if (( n % 2 == 0 ) | ( n == 1 )) { return false ; } for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) { return false ; } } return true ; } PSEUDOPRIME(n) Carmichael numbers 561 1105 1729 1 2 3 4 5 6 7 8 9 10 11 constexpr bool PRIME = true ; constexpr bool COMPOSITE = false ; bool PSEUDOPRIME ( int n ) { if ( MODULAR_EXPONENTIATION ( 2 , n - 1 , n ) != 1 ) { return COMPOSITE ; } return PRIME ; } MILLER_RABIN_primality_test https://casterian.net/archives/396 https://www.acmicpc.net/problem/5615 $O(k \\log^3 n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool WITNESS ( ull a , ull n , ull u , ull t ) { ull x_pre = MODULAR_EXPONENTIATION ( a , u , n ); ull x = x_pre ; for ( int i = 0 ; i < t ; i ++ ) { x = ( x_pre * x_pre ) % n ; if ( x == 1 && x_pre != 1 && x_pre != n - 1 ) { return true ; } x_pre = x ; } if ( x != 1 ) return true ; return false ; } a = 2,3,5,7,11,13,17, 31,61 ,73 \uc815\ub3c4\ub85c\ud560\ub54c \uc815\uc218\ud45c\ud604\uac00\ub2a5\ud55c \ubaa8\ub4e0 \uc18c\uc218\ub97c \ud310\u3134\ubcc4\ud560\uc218\uc788\ub2e4. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 typedef unsigned long long ull ; constexpr bool PRIME = true ; constexpr bool COMPOSITE = false ; bool MILLER_RABIN ( ull n ) { if ( n == 2 ) { return PRIME ; } if ( n == 1 || n % 2 == 0 ) { return COMPOSITE ; } ull t = 0 ; ull u = n - 1 ; while ( u % 2 == 0 ) { t ++ ; u = u >> 1 ; } //, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 61, 73 ull test [] = { 2 , 3 }; for ( auto a : test ) { if ( n == a ) { return PRIME ; } if ( WITNESS ( a , n , u , t )) //\ud569\uc131\uc218\uc77c\uc2dc true \ubc18\ud658 { return COMPOSITE ; } } return PRIME ; //probably } 31.9 Integer factorization https://www.acmicpc.net/problem/4149 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void POLLARED_RHO ( int n ) { int i = 1 ; int x = 2 ; // random n int y = x ; int k = 2 ; int x_n = 0 ; int d = 0 ; while ( 1 ) { i ++ ; x_n = ( x * x - 1 ) % n ; d = EUCLID ( abs ( y - x_n ), n ); if ( d != 1 && d != n ) { std :: cout << d << '\\n' ; } if ( i == k ) { y = x_n ; k = 2 * k ; } x = x_n ; } } Problems 31-2 Binary gcd algorithm 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 unsigned int gcd ( unsigned int u , unsigned int v ) { if ( u == 0 ) { return v ; } if ( v == 0 ) { return u ; } if ((( u & v ) & 1 ) == 0 ) // \uc9dd\uc218 { return ( gcd ( u >> 1 , v >> 1 )) << 1 ; } if (( u & 1 ) == 0 ) // \uc9dd\uc218 { return gcd ( u >> 1 , v ); } if (( v & 1 ) == 0 ) { return gcd ( u , v >> 1 ); } if ( v > u ) { int a = v ; v = u ; u = a ; } else { return gcd (( u - v ) >> 1 , v ); } } 31-3 Three algorighms for Fibonacci numbers (a) $O(2^n)$ 1 2 3 4 5 6 7 8 int Fibonacci_numbers ( int n ) { if ( n == 1 || n == 2 ) { return 1 ; } return Fibonacci_numbers ( n - 1 ) + Fibonacci_numbers ( n - 2 ); } (b) memoization $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int Fibonacci_numbers ( int n ) { if ( n == 1 || n == 2 ) { return 1 ; } int x = 1 , y = 1 ; int Fibonacci = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { Fibonacci = x + y ; x = y ; y = Fibonacci ; } return Fibonacci ; } (c) $O(\\log n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int Fibonacci_numbers ( int n ) { int mat [ 2 ][ 2 ] = { 0 , 1 , 1 , 1 }; int y [ 2 ][ 2 ] = { 0 , 1 , 1 , 1 }; int z [ 2 ][ 2 ] = { 0 , 1 , 1 , 1 }; if ( n == 1 || n == 2 ) { return 1 ; } int a = n - 1 ; while ( a != 0 ) { if ( a & 1 ) { y [ 0 ][ 0 ] = z [ 0 ][ 0 ]; y [ 0 ][ 1 ] = z [ 0 ][ 1 ]; y [ 1 ][ 0 ] = z [ 1 ][ 0 ]; y [ 1 ][ 1 ] = z [ 1 ][ 1 ]; z [ 0 ][ 0 ] = y [ 0 ][ 0 ] * mat [ 0 ][ 0 ] + y [ 1 ][ 0 ] * mat [ 0 ][ 1 ]; z [ 0 ][ 1 ] = y [ 0 ][ 0 ] * mat [ 0 ][ 1 ] + y [ 0 ][ 1 ] * mat [ 1 ][ 1 ]; z [ 1 ][ 0 ] = y [ 1 ][ 0 ] * mat [ 0 ][ 0 ] + y [ 1 ][ 1 ] * mat [ 1 ][ 0 ]; z [ 1 ][ 1 ] = y [ 1 ][ 0 ] * mat [ 0 ][ 1 ] + y [ 1 ][ 1 ] * mat [ 1 ][ 1 ]; } y [ 0 ][ 0 ] = mat [ 0 ][ 0 ]; y [ 0 ][ 1 ] = mat [ 0 ][ 1 ]; y [ 1 ][ 0 ] = mat [ 1 ][ 0 ]; y [ 1 ][ 1 ] = mat [ 1 ][ 1 ]; mat [ 0 ][ 0 ] = y [ 0 ][ 0 ] * y [ 0 ][ 0 ] + y [ 1 ][ 0 ] * y [ 0 ][ 1 ]; mat [ 0 ][ 1 ] = y [ 0 ][ 0 ] * y [ 0 ][ 1 ] + y [ 0 ][ 1 ] * y [ 1 ][ 1 ]; mat [ 1 ][ 0 ] = y [ 0 ][ 0 ] * y [ 1 ][ 0 ] + y [ 1 ][ 0 ] * y [ 1 ][ 1 ]; mat [ 1 ][ 1 ] = y [ 1 ][ 0 ] * y [ 0 ][ 1 ] + y [ 1 ][ 1 ] * y [ 1 ][ 1 ]; a = a >> 1 ; } return z [ 1 ][ 0 ]; }","title":"31 Number-Theoretic Algorithms"},{"location":"ch31/readme/#312","text":"","title":"31.2"},{"location":"ch31/readme/#gcd-euclids-algorithm","text":"$O(\\log b)$ 1 2 3 4 5 6 7 int EUCLID ( int a , int b ) { if ( b == 0 ) return a ; else return EUCLID ( b , a % b ); }","title":"GCD Euclid's algorithm"},{"location":"ch31/readme/#extended_euclid","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <tuple> std :: tuple < int , int , int > EXTENDED_EUCLID ( int a , int b ) { if ( b == 0 ) { std :: tuple < int , int , int > x ( a , 1 , 0 ); return x ; } std :: tuple < int , int , int > x = EXTENDED_EUCLID ( b , a % b ); //d x y std :: tuple < int , int , int > y = std :: make_tuple ( std :: get < 0 > ( x ), std :: get < 2 > ( x ), std :: get < 1 > ( x ) - ( a / b ) * std :: get < 2 > ( x )); return y ; }","title":"EXTENDED_EUCLID"},{"location":"ch31/readme/#314","text":"","title":"31.4"},{"location":"ch31/readme/#modular_linear_equation_solver","text":"$O(\\log n + \\gcd(a,n))$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void MODULAR_LINEAR_EQUATION_SOLVER ( int a , int b , int n ) //ax = b (mod n) { std :: tuple < int , int , int > set = EXTENDED_EUCLID ( a , n ); int d = std :: get < 0 > ( set ); if ( b / d ) { int x_0 = ((( std :: get < 1 > ( set ) * ( b / d )) % n ) + n ) % n ; //x_0 %= n; for ( int i = 0 ; i <= d - 1 ; i ++ ) { std :: cout << ( x_0 + ( i * ( n / d ))) % n << ' ' ; } } else { std :: cout << \"no solution\" ; } }","title":"MODULAR_LINEAR_EQUATION_SOLVER"},{"location":"ch31/readme/#modulo","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int extended_Euclid_for_multiple_inverse ( const int a , const int mod_n ) { if ( gcd ( a , mod_n ) != 1 ) return - 1 ; r1 = a , r2 = mod_n ; t1 = 0 , t2 = 1 ; u , r , t ; while ( r2 > 0 ) { u = r1 / r2 ; r = r1 % r2 ; r1 = r2 ; r2 = r ; t = t1 - u * t2 ; t1 = t2 ; t2 = t ; } if ( t1 < 0 ) t1 += mod_n ; return t1 ; //e }","title":"modulo \uc5f0\uc0b0\uc5d0\ub300\ud55c \uc5ed"},{"location":"ch31/readme/#315-the-chinese-remainder-theorem","text":"https://www.acmicpc.net/problem/1476","title":"31.5 The Chinese remainder theorem"},{"location":"ch31/readme/#316","text":"","title":"31.6"},{"location":"ch31/readme/#_1","text":"CLRS\uc5d0 \uc18c\uac1c\ub41c \uc758\uc0ac\ucf54\ub4dc\ub294 \uc798 \uc791\ub3d9\ud558\uc9c0 \uc54a\ub294\ub2e4. \ucf54\ub4dc\ub97c \uc0b4\ud3b4\ubcf4\uba74 c\ub97c \uc0ac\uc6a9\ud558\uc9c0\uc54a\uc74c d - bit $O(d)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int MODULAR_EXPONENTIATION ( int a , int b , int n ) //a^b mod n { int x = a , y = 1 ; while ( b != 0 ) { if ( b & 1 ) { y = ( x * y ) % n ; } x = ( x * x ) % n ; b = b >> 1 ; } return y ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 int EXPONENTIATION ( int a , int b ) //a^b int x = a , y = 1 ; while ( b != 0 ) { if ( b & 1 ) { y = ( x * y ); } x = ( x * x ); b = b >> 1 ; } return y ; }","title":"\uace0\uc18d \uac70\ub4ed\uc81c\uacf1 \ubaa8\ub4c8\ub7ec \uc5f0\uc0b0"},{"location":"ch31/readme/#317-the-rsa-public-key-crytosystem","text":"Select at random two large prime numbers p and q such that p != q. The primes p and q might be, say, 1024 bits each. Compute n = pq. Select a small odd integer e that is relatively prime to pi(n), which, by equation (31.20), equals (p-1)(q-1) Compute d as the multiplicative inverse of e, modulo pi(n). (Corollary 31.26 guarantees that d exists and is uniquely defined. We can use the technique of Section 31.4 to compute d, given e and pi(n)) Publish the pair P = (e,n) as the participant\u2019s RSA public key. Keep secret the pair S = (d, n) as the participant\u2019s RSA secret key. go to RSA.h","title":"31.7 The RSA public-key crytosystem"},{"location":"ch31/readme/#318-primality-tetsting","text":"$O(\\sqrt{n})$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 bool trial_division ( int n ) { if ( n == 2 ) { return true ; } if (( n % 2 == 0 ) | ( n == 1 )) { return false ; } for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) { return false ; } } return true ; }","title":"31.8 Primality tetsting"},{"location":"ch31/readme/#pseudoprimen","text":"Carmichael numbers 561 1105 1729 1 2 3 4 5 6 7 8 9 10 11 constexpr bool PRIME = true ; constexpr bool COMPOSITE = false ; bool PSEUDOPRIME ( int n ) { if ( MODULAR_EXPONENTIATION ( 2 , n - 1 , n ) != 1 ) { return COMPOSITE ; } return PRIME ; }","title":"PSEUDOPRIME(n)"},{"location":"ch31/readme/#miller_rabin_primality_test","text":"https://casterian.net/archives/396 https://www.acmicpc.net/problem/5615 $O(k \\log^3 n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool WITNESS ( ull a , ull n , ull u , ull t ) { ull x_pre = MODULAR_EXPONENTIATION ( a , u , n ); ull x = x_pre ; for ( int i = 0 ; i < t ; i ++ ) { x = ( x_pre * x_pre ) % n ; if ( x == 1 && x_pre != 1 && x_pre != n - 1 ) { return true ; } x_pre = x ; } if ( x != 1 ) return true ; return false ; } a = 2,3,5,7,11,13,17, 31,61 ,73 \uc815\ub3c4\ub85c\ud560\ub54c \uc815\uc218\ud45c\ud604\uac00\ub2a5\ud55c \ubaa8\ub4e0 \uc18c\uc218\ub97c \ud310\u3134\ubcc4\ud560\uc218\uc788\ub2e4. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 typedef unsigned long long ull ; constexpr bool PRIME = true ; constexpr bool COMPOSITE = false ; bool MILLER_RABIN ( ull n ) { if ( n == 2 ) { return PRIME ; } if ( n == 1 || n % 2 == 0 ) { return COMPOSITE ; } ull t = 0 ; ull u = n - 1 ; while ( u % 2 == 0 ) { t ++ ; u = u >> 1 ; } //, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 61, 73 ull test [] = { 2 , 3 }; for ( auto a : test ) { if ( n == a ) { return PRIME ; } if ( WITNESS ( a , n , u , t )) //\ud569\uc131\uc218\uc77c\uc2dc true \ubc18\ud658 { return COMPOSITE ; } } return PRIME ; //probably }","title":"MILLER_RABIN_primality_test"},{"location":"ch31/readme/#319-integer-factorization","text":"https://www.acmicpc.net/problem/4149 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void POLLARED_RHO ( int n ) { int i = 1 ; int x = 2 ; // random n int y = x ; int k = 2 ; int x_n = 0 ; int d = 0 ; while ( 1 ) { i ++ ; x_n = ( x * x - 1 ) % n ; d = EUCLID ( abs ( y - x_n ), n ); if ( d != 1 && d != n ) { std :: cout << d << '\\n' ; } if ( i == k ) { y = x_n ; k = 2 * k ; } x = x_n ; } }","title":"31.9 Integer factorization"},{"location":"ch31/readme/#problems","text":"","title":"Problems"},{"location":"ch31/readme/#31-2-binary-gcd-algorithm","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 unsigned int gcd ( unsigned int u , unsigned int v ) { if ( u == 0 ) { return v ; } if ( v == 0 ) { return u ; } if ((( u & v ) & 1 ) == 0 ) // \uc9dd\uc218 { return ( gcd ( u >> 1 , v >> 1 )) << 1 ; } if (( u & 1 ) == 0 ) // \uc9dd\uc218 { return gcd ( u >> 1 , v ); } if (( v & 1 ) == 0 ) { return gcd ( u , v >> 1 ); } if ( v > u ) { int a = v ; v = u ; u = a ; } else { return gcd (( u - v ) >> 1 , v ); } }","title":"31-2 Binary gcd algorithm"},{"location":"ch31/readme/#31-3-three-algorighms-for-fibonacci-numbers","text":"(a) $O(2^n)$ 1 2 3 4 5 6 7 8 int Fibonacci_numbers ( int n ) { if ( n == 1 || n == 2 ) { return 1 ; } return Fibonacci_numbers ( n - 1 ) + Fibonacci_numbers ( n - 2 ); } (b) memoization $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int Fibonacci_numbers ( int n ) { if ( n == 1 || n == 2 ) { return 1 ; } int x = 1 , y = 1 ; int Fibonacci = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { Fibonacci = x + y ; x = y ; y = Fibonacci ; } return Fibonacci ; } (c) $O(\\log n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int Fibonacci_numbers ( int n ) { int mat [ 2 ][ 2 ] = { 0 , 1 , 1 , 1 }; int y [ 2 ][ 2 ] = { 0 , 1 , 1 , 1 }; int z [ 2 ][ 2 ] = { 0 , 1 , 1 , 1 }; if ( n == 1 || n == 2 ) { return 1 ; } int a = n - 1 ; while ( a != 0 ) { if ( a & 1 ) { y [ 0 ][ 0 ] = z [ 0 ][ 0 ]; y [ 0 ][ 1 ] = z [ 0 ][ 1 ]; y [ 1 ][ 0 ] = z [ 1 ][ 0 ]; y [ 1 ][ 1 ] = z [ 1 ][ 1 ]; z [ 0 ][ 0 ] = y [ 0 ][ 0 ] * mat [ 0 ][ 0 ] + y [ 1 ][ 0 ] * mat [ 0 ][ 1 ]; z [ 0 ][ 1 ] = y [ 0 ][ 0 ] * mat [ 0 ][ 1 ] + y [ 0 ][ 1 ] * mat [ 1 ][ 1 ]; z [ 1 ][ 0 ] = y [ 1 ][ 0 ] * mat [ 0 ][ 0 ] + y [ 1 ][ 1 ] * mat [ 1 ][ 0 ]; z [ 1 ][ 1 ] = y [ 1 ][ 0 ] * mat [ 0 ][ 1 ] + y [ 1 ][ 1 ] * mat [ 1 ][ 1 ]; } y [ 0 ][ 0 ] = mat [ 0 ][ 0 ]; y [ 0 ][ 1 ] = mat [ 0 ][ 1 ]; y [ 1 ][ 0 ] = mat [ 1 ][ 0 ]; y [ 1 ][ 1 ] = mat [ 1 ][ 1 ]; mat [ 0 ][ 0 ] = y [ 0 ][ 0 ] * y [ 0 ][ 0 ] + y [ 1 ][ 0 ] * y [ 0 ][ 1 ]; mat [ 0 ][ 1 ] = y [ 0 ][ 0 ] * y [ 0 ][ 1 ] + y [ 0 ][ 1 ] * y [ 1 ][ 1 ]; mat [ 1 ][ 0 ] = y [ 0 ][ 0 ] * y [ 1 ][ 0 ] + y [ 1 ][ 0 ] * y [ 1 ][ 1 ]; mat [ 1 ][ 1 ] = y [ 1 ][ 0 ] * y [ 0 ][ 1 ] + y [ 1 ][ 1 ] * y [ 1 ][ 1 ]; a = a >> 1 ; } return z [ 1 ][ 0 ]; }","title":"31-3 Three algorighms for Fibonacci numbers"},{"location":"ch32/readme/","text":"32.1 The naive string matching algorithm m = T.length n = P.length $O((n-m+1)m)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void NAIVE_STRING_MATCHER ( char * T , int m , char * P , int n ) { for ( int s = 0 ; s <= n - m ; s ++ ) { bool matching = true ; // strcmp for ( int i = 0 ; i < m ; i ++ ) { if ( T [ i + s ] != P [ i ]) { matching = false ; } } if ( matching ) { std :: cout << \"Pattern occurs with shift\" << s << '\\n' ; } } } 32.2 The Rabin Karp algorighm Preprocessing time : $O(m)$ Matching time $O((n-m+1)m)$ \ud3c9\uade0 O(m) q = prime $d = \\Sigma ^{*}$ I'm setting d = 26 (only Letter case) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void RABIN_KARP_MATCHER ( char T [], int n , char P [], int m , int d , int q ) { int h = MODULAR_EXPONENTIATION ( d , n - 1 , q ); int p = 0 ; int t_0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) //\uc804\ucc98\ub9ac { p = ( d * p + ( P [ i ] - 'A' )) % q ; t_0 = ( d * t_0 + ( T [ i ] - 'A' )) % q ; } for ( int s = 0 ; s <= m - n ; s ++ ) { if ( p == t_0 ) { bool matching = true ; // strcmp for ( int i = 0 ; i < n ; i ++ ) { if ( T [ i + s ] != P [ i ]) { matching = false ; break ; } } if ( matching ) { std :: cout << \"Pattern occurs with shift\" << s << '\\n' ; } } if ( s < m - n ) { t_0 = (( d * ( t_0 - ( T [ s ] - 'A' ) * h ) + ( T [ s + n ] - 'A' )) % q + q ) % q ; //\uc74c\uc218\uac00 \ub098\uc62c\uc218\uc788\uae30\ub54c\ubb38\uc5d0 \uc74c\uc218\ucc98\ub9ac\ub97c \ud55c\ub2e4. } } } 32.3 String matching with finite automata https://www.acmicpc.net/problem/1786 Preprocessing time : $O(m^{3} |\\Sigma|) $ \ub4a4\uc758 kmp\ub97c \uc751\uc6a9\ud574\uc11c \ud574\ub2f9 \ubcf5\uc7a1\ub3c4\ub97c $O(m|\\Sigma|) $ \ub85c \uc904\uc77c \uc218 \uc788\ub2e4. Matching time $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 void FINITE_AUTOMATON_MATCHER ( char T [], int n , std :: vector < std :: vector < int >> equation , int m ) { int q = 0 ; for ( int i = 0 ; i < n ; i ++ ) { q = equation [ q ][ T [ i ] - 'A' ]; if ( q == m ) { std :: cout << \"Pattern occurs with shift\" << i - m + 1 << '\\n' ; } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 std :: vector < std :: vector < int >> COMPUTE_TRANSITION_FUNCTION ( char P [], int sigma , int m ) // { std :: vector < std :: vector < int >> transition_function ; transition_function . resize ( m + 1 ); for ( int i = 0 ; i <= m ; i ++ ) { transition_function [ i ]. resize ( sigma , 0 ); } for ( int q = 0 ; q <= m ; q ++ ) { for ( char a = 0 ; a < sigma ; a ++ ) { int k = ( m + 1 < q + 2 ? m + 1 : q + 2 ); bool matching = true ; do { k -- ; matching = true ; if ( k == 0 ) { break ; } if ( P [ k - 1 ] != a + 'A' ) // \uc811\ubbf8\uc0ac \ub9e4\uce6d { continue ; } for ( int i = 0 ; i < k ; i ++ ) { if ( k - 2 - i < 0 || q - i < 0 ) { matching = false ; break ; } if ( P [ k - 1 - i ] != P [ q - i ]) { break ; } } } while ( matching ); transition_function [ q ][ a ] = k ; } } return transition_function ; } 32.4 The Knuth-Morris-Pratt algorithm https://www.acmicpc.net/problem/1786 Preprocessing time : $O(m)$ Matching time $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void KMP_MATCHER ( char T [], int n , char P [], int m ) { std :: vector < int > pi = COMPUTE_PREFIX_FUNCTION ( P , m ); int q = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { while ( q >= 0 && P [ q + 1 ] != T [ i ]) { q = pi [ q ]; } if ( P [ q + 1 ] == T [ i ]) { q ++ ; } if ( q + 1 == m ) { std :: cout << \"Pattern occurs with shift\" << i - m + 1 << '\\n' ; q = pi [ q ]; } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 std :: vector < int > COMPUTE_PREFIX_FUNCTION ( char P [], int m ) { std :: vector < int > pi ; pi . resize ( m ); pi [ 0 ] = - 1 ; int k = - 1 ; for ( int q = 1 ; q < m ; q ++ ) { while ( k > 0 && P [ k + 1 ] != P [ q ]) { k = pi [ k ]; } if ( P [ k + 1 ] == P [ q ]) { k ++ ; } pi [ q ] = k ; } return pi ; }","title":"32 String Matching"},{"location":"ch32/readme/#321-the-naive-string-matching-algorithm","text":"m = T.length n = P.length $O((n-m+1)m)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void NAIVE_STRING_MATCHER ( char * T , int m , char * P , int n ) { for ( int s = 0 ; s <= n - m ; s ++ ) { bool matching = true ; // strcmp for ( int i = 0 ; i < m ; i ++ ) { if ( T [ i + s ] != P [ i ]) { matching = false ; } } if ( matching ) { std :: cout << \"Pattern occurs with shift\" << s << '\\n' ; } } }","title":"32.1 The naive string matching algorithm"},{"location":"ch32/readme/#322-the-rabin-karp-algorighm","text":"Preprocessing time : $O(m)$ Matching time $O((n-m+1)m)$ \ud3c9\uade0 O(m) q = prime $d = \\Sigma ^{*}$ I'm setting d = 26 (only Letter case) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void RABIN_KARP_MATCHER ( char T [], int n , char P [], int m , int d , int q ) { int h = MODULAR_EXPONENTIATION ( d , n - 1 , q ); int p = 0 ; int t_0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) //\uc804\ucc98\ub9ac { p = ( d * p + ( P [ i ] - 'A' )) % q ; t_0 = ( d * t_0 + ( T [ i ] - 'A' )) % q ; } for ( int s = 0 ; s <= m - n ; s ++ ) { if ( p == t_0 ) { bool matching = true ; // strcmp for ( int i = 0 ; i < n ; i ++ ) { if ( T [ i + s ] != P [ i ]) { matching = false ; break ; } } if ( matching ) { std :: cout << \"Pattern occurs with shift\" << s << '\\n' ; } } if ( s < m - n ) { t_0 = (( d * ( t_0 - ( T [ s ] - 'A' ) * h ) + ( T [ s + n ] - 'A' )) % q + q ) % q ; //\uc74c\uc218\uac00 \ub098\uc62c\uc218\uc788\uae30\ub54c\ubb38\uc5d0 \uc74c\uc218\ucc98\ub9ac\ub97c \ud55c\ub2e4. } } }","title":"32.2 The Rabin Karp algorighm"},{"location":"ch32/readme/#323-string-matching-with-finite-automata","text":"https://www.acmicpc.net/problem/1786 Preprocessing time : $O(m^{3} |\\Sigma|) $ \ub4a4\uc758 kmp\ub97c \uc751\uc6a9\ud574\uc11c \ud574\ub2f9 \ubcf5\uc7a1\ub3c4\ub97c $O(m|\\Sigma|) $ \ub85c \uc904\uc77c \uc218 \uc788\ub2e4. Matching time $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 void FINITE_AUTOMATON_MATCHER ( char T [], int n , std :: vector < std :: vector < int >> equation , int m ) { int q = 0 ; for ( int i = 0 ; i < n ; i ++ ) { q = equation [ q ][ T [ i ] - 'A' ]; if ( q == m ) { std :: cout << \"Pattern occurs with shift\" << i - m + 1 << '\\n' ; } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 std :: vector < std :: vector < int >> COMPUTE_TRANSITION_FUNCTION ( char P [], int sigma , int m ) // { std :: vector < std :: vector < int >> transition_function ; transition_function . resize ( m + 1 ); for ( int i = 0 ; i <= m ; i ++ ) { transition_function [ i ]. resize ( sigma , 0 ); } for ( int q = 0 ; q <= m ; q ++ ) { for ( char a = 0 ; a < sigma ; a ++ ) { int k = ( m + 1 < q + 2 ? m + 1 : q + 2 ); bool matching = true ; do { k -- ; matching = true ; if ( k == 0 ) { break ; } if ( P [ k - 1 ] != a + 'A' ) // \uc811\ubbf8\uc0ac \ub9e4\uce6d { continue ; } for ( int i = 0 ; i < k ; i ++ ) { if ( k - 2 - i < 0 || q - i < 0 ) { matching = false ; break ; } if ( P [ k - 1 - i ] != P [ q - i ]) { break ; } } } while ( matching ); transition_function [ q ][ a ] = k ; } } return transition_function ; }","title":"32.3 String matching with finite automata"},{"location":"ch32/readme/#324-the-knuth-morris-pratt-algorithm","text":"https://www.acmicpc.net/problem/1786 Preprocessing time : $O(m)$ Matching time $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void KMP_MATCHER ( char T [], int n , char P [], int m ) { std :: vector < int > pi = COMPUTE_PREFIX_FUNCTION ( P , m ); int q = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { while ( q >= 0 && P [ q + 1 ] != T [ i ]) { q = pi [ q ]; } if ( P [ q + 1 ] == T [ i ]) { q ++ ; } if ( q + 1 == m ) { std :: cout << \"Pattern occurs with shift\" << i - m + 1 << '\\n' ; q = pi [ q ]; } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 std :: vector < int > COMPUTE_PREFIX_FUNCTION ( char P [], int m ) { std :: vector < int > pi ; pi . resize ( m ); pi [ 0 ] = - 1 ; int k = - 1 ; for ( int q = 1 ; q < m ; q ++ ) { while ( k > 0 && P [ k + 1 ] != P [ q ]) { k = pi [ k ]; } if ( P [ k + 1 ] == P [ q ]) { k ++ ; } pi [ q ] = k ; } return pi ; }","title":"32.4 The Knuth-Morris-Pratt algorithm"},{"location":"ch33/readme/","text":"33 Computational Geometry 1 2 3 4 5 6 7 8 9 10 11 12 13 struct point { ll x ; ll y ; ll operator * ( const point & p1 ) { return ( x * p1 . y ) - ( p1 . x * y ); } point operator - ( const point & p1 ) { return { x - p1 . x , y - p1 . y }; } }; 33.1 Line-segment properties 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ll DIRECTION ( point pi , point pj , point pk ) { return ( pk - pi ) * ( pj - pi ); } bool ON_SEGMENT ( const point & pi , const point & pj , const point & pk ) { return ( min ( pi . x , pj . x ) <= pk . x && pk . x <= max ( pi . x , pj . x )) && ( min ( pi . y , pj . y ) <= pk . y && pk . y <= max ( pi . y , pj . y )); } bool SEGMENTS_INTERSECT ( const point & p1 , const point & p2 , const point & p3 , const point & p4 ) { ll d1 = DIRECTION ( p3 , p4 , p1 ); ll d2 = DIRECTION ( p3 , p4 , p2 ); ll d3 = DIRECTION ( p1 , p2 , p3 ); ll d4 = DIRECTION ( p1 , p2 , p4 ); if ( (( d1 > 0 && d2 < 0 ) || ( d1 < 0 && d2 > 0 )) && (( d3 > 0 && d4 < 0 ) || ( d3 < 0 && d4 > 0 )) ) { return true ; } else if ( d1 == 0 && ON_SEGMENT ( p3 , p4 , p1 )) { return true ; } else if ( d2 == 0 && ON_SEGMENT ( p3 , p4 , p2 )) { return true ; } else if ( d3 == 0 && ON_SEGMENT ( p1 , p2 , p3 )) { return true ; } else if ( d4 == 0 && ON_SEGMENT ( p1 , p2 , p4 )) { return true ; } else { return false ; } } 33.2 Determining whether any pair of segments intersects 33.3 Finding the convex hull $O(n\\log n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 point p0 ; bool sorty ( const point & a , const point & b ) { if ( a . y != b . y ) { return a . y < b . y ; } return a . x < b . x ; } bool sortCounterClockWise ( const point & p1 , const point & p2 ) { double result = DIRECTION ( p0 , p1 , p2 ); if ( result != 0 ) { return result < 0 ; } return sorty ( p1 , p2 ); } stack < point > GRAHAM_SCAN ( vector < point > & Q ) { sort ( Q . begin (), Q . end (), sorty ); p0 = Q [ 0 ]; sort ( Q . begin () + 1 , Q . end (), sortCounterClockWise ); stack < point > st ; if ( Q . size () < 2 ) return st ; st . push ( Q [ 0 ]); st . push ( Q [ 1 ]); for ( int i = 2 ; i < Q . size (); i ++ ) { while ( st . size () >= 2 ) { point v2 = st . top (); st . pop (); point v3 = st . top (); if ( DIRECTION ( v3 , v2 , Q [ i ]) < 0 ) { st . push ( v2 ); break ; } } st . push ( Q [ i ]); } return st ; } 33.4 Finding the closest pair of points","title":"33 Computational Geometry"},{"location":"ch33/readme/#33-computational-geometry","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 struct point { ll x ; ll y ; ll operator * ( const point & p1 ) { return ( x * p1 . y ) - ( p1 . x * y ); } point operator - ( const point & p1 ) { return { x - p1 . x , y - p1 . y }; } };","title":"33 Computational Geometry"},{"location":"ch33/readme/#331-line-segment-properties","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ll DIRECTION ( point pi , point pj , point pk ) { return ( pk - pi ) * ( pj - pi ); } bool ON_SEGMENT ( const point & pi , const point & pj , const point & pk ) { return ( min ( pi . x , pj . x ) <= pk . x && pk . x <= max ( pi . x , pj . x )) && ( min ( pi . y , pj . y ) <= pk . y && pk . y <= max ( pi . y , pj . y )); } bool SEGMENTS_INTERSECT ( const point & p1 , const point & p2 , const point & p3 , const point & p4 ) { ll d1 = DIRECTION ( p3 , p4 , p1 ); ll d2 = DIRECTION ( p3 , p4 , p2 ); ll d3 = DIRECTION ( p1 , p2 , p3 ); ll d4 = DIRECTION ( p1 , p2 , p4 ); if ( (( d1 > 0 && d2 < 0 ) || ( d1 < 0 && d2 > 0 )) && (( d3 > 0 && d4 < 0 ) || ( d3 < 0 && d4 > 0 )) ) { return true ; } else if ( d1 == 0 && ON_SEGMENT ( p3 , p4 , p1 )) { return true ; } else if ( d2 == 0 && ON_SEGMENT ( p3 , p4 , p2 )) { return true ; } else if ( d3 == 0 && ON_SEGMENT ( p1 , p2 , p3 )) { return true ; } else if ( d4 == 0 && ON_SEGMENT ( p1 , p2 , p4 )) { return true ; } else { return false ; } }","title":"33.1 Line-segment properties"},{"location":"ch33/readme/#332-determining-whether-any-pair-of-segments-intersects","text":"","title":"33.2 Determining whether any pair of segments intersects"},{"location":"ch33/readme/#333-finding-the-convex-hull","text":"$O(n\\log n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 point p0 ; bool sorty ( const point & a , const point & b ) { if ( a . y != b . y ) { return a . y < b . y ; } return a . x < b . x ; } bool sortCounterClockWise ( const point & p1 , const point & p2 ) { double result = DIRECTION ( p0 , p1 , p2 ); if ( result != 0 ) { return result < 0 ; } return sorty ( p1 , p2 ); } stack < point > GRAHAM_SCAN ( vector < point > & Q ) { sort ( Q . begin (), Q . end (), sorty ); p0 = Q [ 0 ]; sort ( Q . begin () + 1 , Q . end (), sortCounterClockWise ); stack < point > st ; if ( Q . size () < 2 ) return st ; st . push ( Q [ 0 ]); st . push ( Q [ 1 ]); for ( int i = 2 ; i < Q . size (); i ++ ) { while ( st . size () >= 2 ) { point v2 = st . top (); st . pop (); point v3 = st . top (); if ( DIRECTION ( v3 , v2 , Q [ i ]) < 0 ) { st . push ( v2 ); break ; } } st . push ( Q [ i ]); } return st ; }","title":"33.3 Finding the convex hull"},{"location":"ch33/readme/#334-finding-the-closest-pair-of-points","text":"","title":"33.4 Finding the closest pair of points"},{"location":"ch4/readme/","text":"4.1 The maximum-subarray problem boj 4.1-2 A brute-force solution $\\Theta(n^2)$ daq $\\Theta(n\\log n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 struct subset { long long low ; long long high ; long long sum ; }; subset FIND_MAX_CROSSING_SUBARRAY ( long long A [], long long low , long long mid , long long high ) { long long left_sum = A [ mid ] - 1 ; long long sum = 0 ; long long max_left = 0 ; long long max_right = 0 ; long long right_sum = 0 ; for ( long long i = mid ; i >= low ; i -- ) { sum = sum + A [ i ]; if ( sum > left_sum ) { left_sum = sum ; max_left = i ; } } right_sum = A [ mid + 1 ] - 1 ; sum = 0 ; for ( long long j = mid + 1 ; j <= high ; j ++ ) { sum = sum + A [ j ]; if ( sum > right_sum ) { right_sum = sum ; max_right = j ; } } return { max_left , max_right , left_sum + right_sum }; } subset FIND_MAXIMUM_SUBARRAY ( long long A [], long long low , long long high ) { if ( high == low ) { return { low , high , A [ low ] }; // base case: only one element } else { long long mid = ( low + high ) / 2 ; subset LEFT = FIND_MAXIMUM_SUBARRAY ( A , low , mid ); subset RIGHT = FIND_MAXIMUM_SUBARRAY ( A , mid + 1 , high ); subset CROSS = FIND_MAX_CROSSING_SUBARRAY ( A , low , mid , high ); if ( LEFT . sum >= RIGHT . sum && LEFT . sum >= CROSS . sum ) { return LEFT ; } else if ( RIGHT . sum >= LEFT . sum && RIGHT . sum >= CROSS . sum ) { return RIGHT ; } else { return CROSS ; } } } 4.1-5 Kadane\u2019s Algorithm $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct subset { long long low ; long long high ; long long sum ; }; subset KADANE ( int A [], int n ) { subset current_sum = { 0 , 0 , A [ 0 ] }; subset maximum = { 0 , 0 , A [ 0 ] }; for ( int i = 1 ; i < n ; i ++ ) { if ( current_sum . sum + A [ i ] > A [ i ]) { if ( current_sum . sum == 0 ) current_sum . low = i ; current_sum . sum = current_sum . sum + A [ i ]; current_sum . high = i ; } else { current_sum . sum = A [ i ]; } if ( maximum . sum < current_sum . sum ) { maximum . low = current_sum . low ; maximum . high = current_sum . high ; maximum . sum = current_sum . sum ; } } return maximum ; } 4.2 Strassen's algorithms for matrix multiplication \uc77c\ubc18 $O(n^3)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 std :: vector < std :: vector < int >> SQUARE_MATRIX_MULTIPLY ( std :: vector < std :: vector < int >>& A , std :: vector < std :: vector < int >>& B ) { const int n = A . size (); std :: vector < std :: vector < int >> C ; C . assign ( n , std :: vector < int > ( n , 0 )); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { C [ i ][ j ] = C [ i ][ j ] + A [ i ][ k ] * B [ k ][ j ]; } } } return C ; } divide and conquer $n = 2^t$ $O(n^3)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 std :: vector < std :: vector < int >> SQUARE_MATRIX_MULTIPLY_RECURSIVE ( std :: vector < std :: vector < int >>& A , std :: vector < std :: vector < int >>& B ); void ADD_MATRIX ( std :: vector < std :: vector < int >> & C , std :: vector < std :: vector < int >> A , std :: vector < std :: vector < int >> B ) { const std :: size_t n = C . size (); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { C [ i ][ j ] = A [ i ][ j ] + B [ i ][ j ]; } } } std :: vector < std :: vector < int >> SQUARE_MATRIX_MULTIPLY_RECURSIVE ( std :: vector < std :: vector < int >> & A , std :: vector < std :: vector < int >> & B ) { const std :: size_t n = A . size (); std :: vector < std :: vector < int >> C ( n , std :: vector < int > ( n , 0 )); if ( n == 1 ) { C [ 0 ][ 0 ] = A [ 0 ][ 0 ] * B [ 0 ][ 0 ]; return C ; } int m = n / 2 ; std :: vector < std :: vector < int >> A11 ( m , std :: vector < int > ( m , 0 )), A12 ( m , std :: vector < int > ( m , 0 )), A21 ( m , std :: vector < int > ( m , 0 )), A22 ( m , std :: vector < int > ( m , 0 )); std :: vector < std :: vector < int >> B11 ( m , std :: vector < int > ( m , 0 )), B12 ( m , std :: vector < int > ( m , 0 )), B21 ( m , std :: vector < int > ( m , 0 )), B22 ( m , std :: vector < int > ( m , 0 )); std :: vector < std :: vector < int >> C11 ( m , std :: vector < int > ( m , 0 )), C12 ( m , std :: vector < int > ( m , 0 )), C21 ( m , std :: vector < int > ( m , 0 )), C22 ( m , std :: vector < int > ( m , 0 )); for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { A11 [ i ][ j ] = A [ i ][ j ]; A12 [ i ][ j ] = A [ i ][ j + m ]; A21 [ i ][ j ] = A [ i + m ][ j ]; A22 [ i ][ j ] = A [ i + m ][ j + m ]; B11 [ i ][ j ] = B [ i ][ j ]; B12 [ i ][ j ] = B [ i ][ j + m ]; B21 [ i ][ j ] = B [ i + m ][ j ]; B22 [ i ][ j ] = B [ i + m ][ j + m ]; } } ADD_MATRIX ( C11 , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A11 , B11 ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A12 , B21 )); ADD_MATRIX ( C12 , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A11 , B12 ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A12 , B22 )); ADD_MATRIX ( C21 , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A21 , B11 ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A22 , B21 )); ADD_MATRIX ( C22 , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A21 , B12 ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A22 , B22 )); for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < n / 2 ; j ++ ) { C [ i ][ j ] = C11 [ i ][ j ]; C [ i ][ j + m ] = C12 [ i ][ j ]; C [ i + m ][ j ] = C21 [ i ][ j ]; C [ i + m ][ j + m ] = C22 [ i ][ j ]; } } return C ; } C\uc774\uc678\uc758 \ucd94\uac00\uc801\uc778 \uacf5\uac04\uc744 \uc0ac\uc6a9\ud558\uc9c0\uc54a\uc74c \ubaa8\ub450 \uc778\ub371\uc2a4\ub85c \ucc98\ub9ac 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 std :: vector < std :: vector < int >> SQUARE_MATRIX_MULTIPLY_RECURSIVE ( int C_row_index , int C_col_index , std :: vector < std :: vector < int >> A , int A_row_index , int A_col_index , std :: vector < std :: vector < int >> B , int B_row_index , int B_col_index , int size ); void ADD_MATRIX ( std :: vector < std :: vector < int >> & C , int C_row_index , int C_col_index , std :: vector < std :: vector < int >> A , std :: vector < std :: vector < int >> B ) { const std :: size_t n = A . size (); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { C [ i + C_row_index ][ j + C_col_index ] = A [ i ][ j ] + B [ i ][ j ]; } } } std :: vector < std :: vector < int >> SQUARE_MATRIX_MULTIPLY_RECURSIVE ( int C_row_index , int C_col_index , std :: vector < std :: vector < int >> A , int A_row_index , int A_col_index , std :: vector < std :: vector < int >> B , int B_row_index , int B_col_index , int size ) { std :: vector < std :: vector < int >> C ( size , std :: vector < int > ( size , 0 )); if ( size == 1 ) { C [ 0 ][ 0 ] = A [ A_row_index ][ A_col_index ] * B [ B_row_index ][ B_col_index ]; return C ; } int m = size / 2 ; ADD_MATRIX ( C , C_row_index , C_col_index , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index , C_col_index , A , A_row_index , A_col_index , B , B_row_index , B_col_index , m ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index , C_col_index , A , A_row_index , A_col_index + m , B , B_row_index + m , B_col_index , m ) ); ADD_MATRIX ( C , C_row_index , C_col_index + m , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index , C_col_index + m , A , A_row_index , A_col_index , B , B_row_index , B_col_index + m , m ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index , C_col_index + m , A , A_row_index , A_col_index + m , B , B_row_index + m , B_col_index + m , m ) ); ADD_MATRIX ( C , C_row_index + m , C_col_index , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index + m , C_col_index , A , A_row_index + m , A_col_index , B , B_row_index , B_col_index , m ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index + m , C_col_index , A , A_row_index + m , A_col_index + m , B , B_row_index + m , B_col_index , m ) ); ADD_MATRIX ( C , C_row_index + m , C_col_index + m , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index + m , C_col_index + m , A , A_row_index + m , A_col_index , B , B_row_index , B_col_index + m , m ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index + m , C_col_index + m , A , A_row_index + m , A_col_index + m , B , B_row_index + m , B_col_index + m , m ) ); return C ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 SQUARE_MATRIX_MULTIPLY_RECURSIVE ( 0 , 0 , A , 0 , 0 , B , 0 , 0 , 2 ); ``` C ++ \uc2a4\ud2b8\ub77c\uc13c ; ``` C ++ void ADD_MATRIX ( std :: vector < std :: vector < int >>& C , std :: vector < std :: vector < int >>& A , std :: vector < std :: vector < int >>& B ) { const std :: size_t n = C . size (); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { C [ i ][ j ] = A [ i ][ j ] + B [ i ][ j ]; } } } void SUB_MATRIX ( std :: vector < std :: vector < int >>& C , std :: vector < std :: vector < int >>& A , std :: vector < std :: vector < int >>& B ) { const std :: size_t n = C . size (); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { C [ i ][ j ] = A [ i ][ j ] - B [ i ][ j ]; } } } std :: vector < std :: vector < int >> STRASSEN ( std :: vector < std :: vector < int >>& A , std :: vector < std :: vector < int >>& B ) { const std :: size_t n = A . size (); std :: vector < std :: vector < int >> C ( n , std :: vector < int > ( n , 0 )); if ( n == 1 ) { C [ 0 ][ 0 ] = A [ 0 ][ 0 ] * B [ 0 ][ 0 ]; return C ; } int m = n / 2 ; std :: vector < std :: vector < int >> A11 ( m , std :: vector < int > ( m , 0 )), A12 ( m , std :: vector < int > ( m , 0 )), A21 ( m , std :: vector < int > ( m , 0 )), A22 ( m , std :: vector < int > ( m , 0 )); std :: vector < std :: vector < int >> B11 ( m , std :: vector < int > ( m , 0 )), B12 ( m , std :: vector < int > ( m , 0 )), B21 ( m , std :: vector < int > ( m , 0 )), B22 ( m , std :: vector < int > ( m , 0 )); std :: vector < std :: vector < int >> S1 ( m , std :: vector < int > ( m , 0 )), S2 ( m , std :: vector < int > ( m , 0 )), S3 ( m , std :: vector < int > ( m , 0 )), S4 ( m , std :: vector < int > ( m , 0 )), S5 ( m , std :: vector < int > ( m , 0 )), S6 ( m , std :: vector < int > ( m , 0 )), S7 ( m , std :: vector < int > ( m , 0 )), S8 ( m , std :: vector < int > ( m , 0 )), S9 ( m , std :: vector < int > ( m , 0 )), S10 ( m , std :: vector < int > ( m , 0 )); std :: vector < std :: vector < int >> P1 ( m , std :: vector < int > ( m , 0 )), P2 ( m , std :: vector < int > ( m , 0 )), P3 ( m , std :: vector < int > ( m , 0 )), P4 ( m , std :: vector < int > ( m , 0 )), P5 ( m , std :: vector < int > ( m , 0 )), P6 ( m , std :: vector < int > ( m , 0 )), P7 ( m , std :: vector < int > ( m , 0 )); for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { A11 [ i ][ j ] = A [ i ][ j ]; A12 [ i ][ j ] = A [ i ][ j + m ]; A21 [ i ][ j ] = A [ i + m ][ j ]; A22 [ i ][ j ] = A [ i + m ][ j + m ]; B11 [ i ][ j ] = B [ i ][ j ]; B12 [ i ][ j ] = B [ i ][ j + m ]; B21 [ i ][ j ] = B [ i + m ][ j ]; B22 [ i ][ j ] = B [ i + m ][ j + m ]; } } SUB_MATRIX ( S1 , B12 , B22 ); ADD_MATRIX ( S2 , A11 , A12 ); ADD_MATRIX ( S3 , A21 , A22 ); SUB_MATRIX ( S4 , B21 , B11 ); ADD_MATRIX ( S5 , A11 , A22 ); ADD_MATRIX ( S6 , B11 , B22 ); SUB_MATRIX ( S7 , A12 , A22 ); ADD_MATRIX ( S8 , B21 , B22 ); SUB_MATRIX ( S9 , A11 , A21 ); ADD_MATRIX ( S10 , B11 , B12 ); P1 = STRASSEN ( A11 , S1 ); P2 = STRASSEN ( S2 , B22 ); P3 = STRASSEN ( S3 , B11 ); P4 = STRASSEN ( A22 , S4 ); P5 = STRASSEN ( S5 , S6 ); P6 = STRASSEN ( S7 , S8 ); P7 = STRASSEN ( S9 , S10 ); for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < n / 2 ; j ++ ) { C [ i ][ j ] = P5 [ i ][ j ] + P4 [ i ][ j ] - P2 [ i ][ j ] + P6 [ i ][ j ]; C [ i ][ j + m ] = P1 [ i ][ j ] + P2 [ i ][ j ]; C [ i + m ][ j ] = P3 [ i ][ j ] + P4 [ i ][ j ]; C [ i + m ][ j + m ] = P5 [ i ][ j ] + P1 [ i ][ j ] - P3 [ i ][ j ] - P7 [ i ][ j ]; } } return C ; }","title":"4 Divide-and-Conquer"},{"location":"ch4/readme/#41-the-maximum-subarray-problem","text":"boj 4.1-2 A brute-force solution $\\Theta(n^2)$ daq $\\Theta(n\\log n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 struct subset { long long low ; long long high ; long long sum ; }; subset FIND_MAX_CROSSING_SUBARRAY ( long long A [], long long low , long long mid , long long high ) { long long left_sum = A [ mid ] - 1 ; long long sum = 0 ; long long max_left = 0 ; long long max_right = 0 ; long long right_sum = 0 ; for ( long long i = mid ; i >= low ; i -- ) { sum = sum + A [ i ]; if ( sum > left_sum ) { left_sum = sum ; max_left = i ; } } right_sum = A [ mid + 1 ] - 1 ; sum = 0 ; for ( long long j = mid + 1 ; j <= high ; j ++ ) { sum = sum + A [ j ]; if ( sum > right_sum ) { right_sum = sum ; max_right = j ; } } return { max_left , max_right , left_sum + right_sum }; } subset FIND_MAXIMUM_SUBARRAY ( long long A [], long long low , long long high ) { if ( high == low ) { return { low , high , A [ low ] }; // base case: only one element } else { long long mid = ( low + high ) / 2 ; subset LEFT = FIND_MAXIMUM_SUBARRAY ( A , low , mid ); subset RIGHT = FIND_MAXIMUM_SUBARRAY ( A , mid + 1 , high ); subset CROSS = FIND_MAX_CROSSING_SUBARRAY ( A , low , mid , high ); if ( LEFT . sum >= RIGHT . sum && LEFT . sum >= CROSS . sum ) { return LEFT ; } else if ( RIGHT . sum >= LEFT . sum && RIGHT . sum >= CROSS . sum ) { return RIGHT ; } else { return CROSS ; } } } 4.1-5 Kadane\u2019s Algorithm $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct subset { long long low ; long long high ; long long sum ; }; subset KADANE ( int A [], int n ) { subset current_sum = { 0 , 0 , A [ 0 ] }; subset maximum = { 0 , 0 , A [ 0 ] }; for ( int i = 1 ; i < n ; i ++ ) { if ( current_sum . sum + A [ i ] > A [ i ]) { if ( current_sum . sum == 0 ) current_sum . low = i ; current_sum . sum = current_sum . sum + A [ i ]; current_sum . high = i ; } else { current_sum . sum = A [ i ]; } if ( maximum . sum < current_sum . sum ) { maximum . low = current_sum . low ; maximum . high = current_sum . high ; maximum . sum = current_sum . sum ; } } return maximum ; }","title":"4.1 The maximum-subarray problem"},{"location":"ch4/readme/#42-strassens-algorithms-for-matrix-multiplication","text":"\uc77c\ubc18 $O(n^3)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 std :: vector < std :: vector < int >> SQUARE_MATRIX_MULTIPLY ( std :: vector < std :: vector < int >>& A , std :: vector < std :: vector < int >>& B ) { const int n = A . size (); std :: vector < std :: vector < int >> C ; C . assign ( n , std :: vector < int > ( n , 0 )); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { C [ i ][ j ] = C [ i ][ j ] + A [ i ][ k ] * B [ k ][ j ]; } } } return C ; } divide and conquer $n = 2^t$ $O(n^3)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 std :: vector < std :: vector < int >> SQUARE_MATRIX_MULTIPLY_RECURSIVE ( std :: vector < std :: vector < int >>& A , std :: vector < std :: vector < int >>& B ); void ADD_MATRIX ( std :: vector < std :: vector < int >> & C , std :: vector < std :: vector < int >> A , std :: vector < std :: vector < int >> B ) { const std :: size_t n = C . size (); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { C [ i ][ j ] = A [ i ][ j ] + B [ i ][ j ]; } } } std :: vector < std :: vector < int >> SQUARE_MATRIX_MULTIPLY_RECURSIVE ( std :: vector < std :: vector < int >> & A , std :: vector < std :: vector < int >> & B ) { const std :: size_t n = A . size (); std :: vector < std :: vector < int >> C ( n , std :: vector < int > ( n , 0 )); if ( n == 1 ) { C [ 0 ][ 0 ] = A [ 0 ][ 0 ] * B [ 0 ][ 0 ]; return C ; } int m = n / 2 ; std :: vector < std :: vector < int >> A11 ( m , std :: vector < int > ( m , 0 )), A12 ( m , std :: vector < int > ( m , 0 )), A21 ( m , std :: vector < int > ( m , 0 )), A22 ( m , std :: vector < int > ( m , 0 )); std :: vector < std :: vector < int >> B11 ( m , std :: vector < int > ( m , 0 )), B12 ( m , std :: vector < int > ( m , 0 )), B21 ( m , std :: vector < int > ( m , 0 )), B22 ( m , std :: vector < int > ( m , 0 )); std :: vector < std :: vector < int >> C11 ( m , std :: vector < int > ( m , 0 )), C12 ( m , std :: vector < int > ( m , 0 )), C21 ( m , std :: vector < int > ( m , 0 )), C22 ( m , std :: vector < int > ( m , 0 )); for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { A11 [ i ][ j ] = A [ i ][ j ]; A12 [ i ][ j ] = A [ i ][ j + m ]; A21 [ i ][ j ] = A [ i + m ][ j ]; A22 [ i ][ j ] = A [ i + m ][ j + m ]; B11 [ i ][ j ] = B [ i ][ j ]; B12 [ i ][ j ] = B [ i ][ j + m ]; B21 [ i ][ j ] = B [ i + m ][ j ]; B22 [ i ][ j ] = B [ i + m ][ j + m ]; } } ADD_MATRIX ( C11 , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A11 , B11 ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A12 , B21 )); ADD_MATRIX ( C12 , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A11 , B12 ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A12 , B22 )); ADD_MATRIX ( C21 , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A21 , B11 ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A22 , B21 )); ADD_MATRIX ( C22 , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A21 , B12 ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( A22 , B22 )); for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < n / 2 ; j ++ ) { C [ i ][ j ] = C11 [ i ][ j ]; C [ i ][ j + m ] = C12 [ i ][ j ]; C [ i + m ][ j ] = C21 [ i ][ j ]; C [ i + m ][ j + m ] = C22 [ i ][ j ]; } } return C ; } C\uc774\uc678\uc758 \ucd94\uac00\uc801\uc778 \uacf5\uac04\uc744 \uc0ac\uc6a9\ud558\uc9c0\uc54a\uc74c \ubaa8\ub450 \uc778\ub371\uc2a4\ub85c \ucc98\ub9ac 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 std :: vector < std :: vector < int >> SQUARE_MATRIX_MULTIPLY_RECURSIVE ( int C_row_index , int C_col_index , std :: vector < std :: vector < int >> A , int A_row_index , int A_col_index , std :: vector < std :: vector < int >> B , int B_row_index , int B_col_index , int size ); void ADD_MATRIX ( std :: vector < std :: vector < int >> & C , int C_row_index , int C_col_index , std :: vector < std :: vector < int >> A , std :: vector < std :: vector < int >> B ) { const std :: size_t n = A . size (); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { C [ i + C_row_index ][ j + C_col_index ] = A [ i ][ j ] + B [ i ][ j ]; } } } std :: vector < std :: vector < int >> SQUARE_MATRIX_MULTIPLY_RECURSIVE ( int C_row_index , int C_col_index , std :: vector < std :: vector < int >> A , int A_row_index , int A_col_index , std :: vector < std :: vector < int >> B , int B_row_index , int B_col_index , int size ) { std :: vector < std :: vector < int >> C ( size , std :: vector < int > ( size , 0 )); if ( size == 1 ) { C [ 0 ][ 0 ] = A [ A_row_index ][ A_col_index ] * B [ B_row_index ][ B_col_index ]; return C ; } int m = size / 2 ; ADD_MATRIX ( C , C_row_index , C_col_index , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index , C_col_index , A , A_row_index , A_col_index , B , B_row_index , B_col_index , m ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index , C_col_index , A , A_row_index , A_col_index + m , B , B_row_index + m , B_col_index , m ) ); ADD_MATRIX ( C , C_row_index , C_col_index + m , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index , C_col_index + m , A , A_row_index , A_col_index , B , B_row_index , B_col_index + m , m ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index , C_col_index + m , A , A_row_index , A_col_index + m , B , B_row_index + m , B_col_index + m , m ) ); ADD_MATRIX ( C , C_row_index + m , C_col_index , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index + m , C_col_index , A , A_row_index + m , A_col_index , B , B_row_index , B_col_index , m ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index + m , C_col_index , A , A_row_index + m , A_col_index + m , B , B_row_index + m , B_col_index , m ) ); ADD_MATRIX ( C , C_row_index + m , C_col_index + m , SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index + m , C_col_index + m , A , A_row_index + m , A_col_index , B , B_row_index , B_col_index + m , m ), SQUARE_MATRIX_MULTIPLY_RECURSIVE ( C_row_index + m , C_col_index + m , A , A_row_index + m , A_col_index + m , B , B_row_index + m , B_col_index + m , m ) ); return C ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 SQUARE_MATRIX_MULTIPLY_RECURSIVE ( 0 , 0 , A , 0 , 0 , B , 0 , 0 , 2 ); ``` C ++ \uc2a4\ud2b8\ub77c\uc13c ; ``` C ++ void ADD_MATRIX ( std :: vector < std :: vector < int >>& C , std :: vector < std :: vector < int >>& A , std :: vector < std :: vector < int >>& B ) { const std :: size_t n = C . size (); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { C [ i ][ j ] = A [ i ][ j ] + B [ i ][ j ]; } } } void SUB_MATRIX ( std :: vector < std :: vector < int >>& C , std :: vector < std :: vector < int >>& A , std :: vector < std :: vector < int >>& B ) { const std :: size_t n = C . size (); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { C [ i ][ j ] = A [ i ][ j ] - B [ i ][ j ]; } } } std :: vector < std :: vector < int >> STRASSEN ( std :: vector < std :: vector < int >>& A , std :: vector < std :: vector < int >>& B ) { const std :: size_t n = A . size (); std :: vector < std :: vector < int >> C ( n , std :: vector < int > ( n , 0 )); if ( n == 1 ) { C [ 0 ][ 0 ] = A [ 0 ][ 0 ] * B [ 0 ][ 0 ]; return C ; } int m = n / 2 ; std :: vector < std :: vector < int >> A11 ( m , std :: vector < int > ( m , 0 )), A12 ( m , std :: vector < int > ( m , 0 )), A21 ( m , std :: vector < int > ( m , 0 )), A22 ( m , std :: vector < int > ( m , 0 )); std :: vector < std :: vector < int >> B11 ( m , std :: vector < int > ( m , 0 )), B12 ( m , std :: vector < int > ( m , 0 )), B21 ( m , std :: vector < int > ( m , 0 )), B22 ( m , std :: vector < int > ( m , 0 )); std :: vector < std :: vector < int >> S1 ( m , std :: vector < int > ( m , 0 )), S2 ( m , std :: vector < int > ( m , 0 )), S3 ( m , std :: vector < int > ( m , 0 )), S4 ( m , std :: vector < int > ( m , 0 )), S5 ( m , std :: vector < int > ( m , 0 )), S6 ( m , std :: vector < int > ( m , 0 )), S7 ( m , std :: vector < int > ( m , 0 )), S8 ( m , std :: vector < int > ( m , 0 )), S9 ( m , std :: vector < int > ( m , 0 )), S10 ( m , std :: vector < int > ( m , 0 )); std :: vector < std :: vector < int >> P1 ( m , std :: vector < int > ( m , 0 )), P2 ( m , std :: vector < int > ( m , 0 )), P3 ( m , std :: vector < int > ( m , 0 )), P4 ( m , std :: vector < int > ( m , 0 )), P5 ( m , std :: vector < int > ( m , 0 )), P6 ( m , std :: vector < int > ( m , 0 )), P7 ( m , std :: vector < int > ( m , 0 )); for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { A11 [ i ][ j ] = A [ i ][ j ]; A12 [ i ][ j ] = A [ i ][ j + m ]; A21 [ i ][ j ] = A [ i + m ][ j ]; A22 [ i ][ j ] = A [ i + m ][ j + m ]; B11 [ i ][ j ] = B [ i ][ j ]; B12 [ i ][ j ] = B [ i ][ j + m ]; B21 [ i ][ j ] = B [ i + m ][ j ]; B22 [ i ][ j ] = B [ i + m ][ j + m ]; } } SUB_MATRIX ( S1 , B12 , B22 ); ADD_MATRIX ( S2 , A11 , A12 ); ADD_MATRIX ( S3 , A21 , A22 ); SUB_MATRIX ( S4 , B21 , B11 ); ADD_MATRIX ( S5 , A11 , A22 ); ADD_MATRIX ( S6 , B11 , B22 ); SUB_MATRIX ( S7 , A12 , A22 ); ADD_MATRIX ( S8 , B21 , B22 ); SUB_MATRIX ( S9 , A11 , A21 ); ADD_MATRIX ( S10 , B11 , B12 ); P1 = STRASSEN ( A11 , S1 ); P2 = STRASSEN ( S2 , B22 ); P3 = STRASSEN ( S3 , B11 ); P4 = STRASSEN ( A22 , S4 ); P5 = STRASSEN ( S5 , S6 ); P6 = STRASSEN ( S7 , S8 ); P7 = STRASSEN ( S9 , S10 ); for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < n / 2 ; j ++ ) { C [ i ][ j ] = P5 [ i ][ j ] + P4 [ i ][ j ] - P2 [ i ][ j ] + P6 [ i ][ j ]; C [ i ][ j + m ] = P1 [ i ][ j ] + P2 [ i ][ j ]; C [ i + m ][ j ] = P3 [ i ][ j ] + P4 [ i ][ j ]; C [ i + m ][ j + m ] = P5 [ i ][ j ] + P1 [ i ][ j ] - P3 [ i ][ j ] - P7 [ i ][ j ]; } } return C ; }","title":"4.2 Strassen's algorithms for matrix multiplication"},{"location":"ch9/readme/","text":"9.1 Minimum and maximum 1 2 3 4 5 6 7 8 9 10 11 12 int MINIMUM ( int A [], int n ) { int min = A [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( min > A [ i ]) { min = A [ i ]; } } return min ; } 1 2 3 4 5 6 7 8 9 10 11 12 int MAXIMUM ( int A [], int n ) { int max = A [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( max < A [ i ]) { max = A [ i ]; } } return max ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int second_MINIMUM ( int A [], int n ) { int min = A [ 0 ]; int sub_min = A [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( min > A [ i ]) { sub_min = min ; min = A [ i ]; } } return sub_min ; } 9.2 Selection in expected linear time 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int PARTITION ( int A [], int p , int r ) { int x = A [ r ]; //pivot int i = p - 1 ; for ( int j = p ; j < r - 1 ; j ++ ) { if ( A [ j ] <= x ) { i ++ ; std :: swap ( A [ i ], A [ j ]); } } std :: swap ( A [ i + 1 ], A [ r ]); return i + 1 ; } int RANDOMIZED_SELECT ( int A [], int p , int r , int i ) { if ( p == r ) return A [ p ]; int q = PARTITION ( A , p , r ); int k = q - p + 1 ; if ( i - 1 == k ) return A [ q ]; else if ( i < k ) return RANDOMIZED_SELECT ( A , p , q - 1 , i ); else return RANDOMIZED_SELECT ( A , q + 1 , r , i - k ); } 9.3 Selection in worst-case linear time Median of medians https://en.wikipedia.org/wiki/Median_of_medians Divide the n elements of the input array into bn=5c groups of 5 elements each and at most one group made up of the remaining n mod 5 elements. Find the median of each of the dn=5e groups by first insertion-sorting the elements of each group (of which there are at most 5) and then picking the median from the sorted list of group elements. Use SELECT recursively to find the median x of the dn=5e medians found in step 2. (If there are an even number of medians, then by our convention, x is the lower median.) Partition the input array around the median-of-medians x using the modified version of PARTITION. Let k be one more than the number of elements on the low side of the partition, so that x is the kth smallest element and there are n\u0005k elements on the high side of the partition. If i D k, then return x. Otherwise, use SELECT recursively to find the i th smallest element on the low side if i < k, or the .i \u0005 k/th smallest element on the high side if i > k. https://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array-set-3-worst-case-linear-time/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 // C++ implementation of worst case linear time algorithm // to find k'th smallest element #include <iostream> #include <algorithm> #include <climits> using namespace std ; int partition ( int arr [], int l , int r , int k ); // A simple function to find median of arr[]. This is called // only for an array of size 5 in this program. int findMedian ( int arr [], int n ) { sort ( arr , arr + n ); // Sort the array return arr [ n / 2 ]; // Return middle element } // Returns k'th smallest element in arr[l..r] in worst case // linear time. ASSUMPTION: ALL ELEMENTS IN ARR[] ARE DISTINCT int kthSmallest ( int arr [], int l , int r , int k ) { // If k is smaller than number of elements in array if ( k > 0 && k <= r - l + 1 ) { int n = r - l + 1 ; // Number of elements in arr[l..r] // Divide arr[] in groups of size 5, calculate median // of every group and store it in median[] array. int i ; int * median = new int [( n + 4 ) / 5 ]; // There will be floor((n+4)/5) groups; for ( i = 0 ; i < n / 5 ; i ++ ) median [ i ] = findMedian ( arr + l + i * 5 , 5 ); if ( i * 5 < n ) //For last group with less than 5 elements { median [ i ] = findMedian ( arr + l + i * 5 , n % 5 ); i ++ ; } // Find median of all medians using recursive call. // If median[] has only one element, then no need // of recursive call int medOfMed = ( i == 1 ) ? median [ i - 1 ] : kthSmallest ( median , 0 , i - 1 , i / 2 ); // Partition the array around a random element and // get position of pivot element in sorted array int pos = partition ( arr , l , r , medOfMed ); delete [] median ; // If position is same as k if ( pos - l == k - 1 ) return arr [ pos ]; if ( pos - l > k - 1 ) // If position is more, recur for left return kthSmallest ( arr , l , pos - 1 , k ); // Else recur for right subarray return kthSmallest ( arr , pos + 1 , r , k - pos + l - 1 ); } // If k is more than number of elements in array return INT_MAX ; } void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } // It searches for x in arr[l..r], and partitions the array // around x. int partition ( int arr [], int l , int r , int x ) { // Search for x in arr[l..r] and move it to end int i ; for ( i = l ; i < r ; i ++ ) if ( arr [ i ] == x ) break ; swap ( & arr [ i ], & arr [ r ]); // Standard partition algorithm i = l ; for ( int j = l ; j <= r - 1 ; j ++ ) { if ( arr [ j ] <= x ) { swap ( & arr [ i ], & arr [ j ]); i ++ ; } } swap ( & arr [ i ], & arr [ r ]); return i ; } // Driver program to test above methods int main () { int arr [] = { 12 , 3 , 5 , 7 , 4 , 19 , 26 }; int n = sizeof ( arr ) / sizeof ( arr [ 0 ]), k = 5 ; cout << \"K'th smallest element is \" << kthSmallest ( arr , 0 , n - 1 , k ); return 0 ; }","title":"9 Medians and Order Statistics"},{"location":"ch9/readme/#91-minimum-and-maximum","text":"1 2 3 4 5 6 7 8 9 10 11 12 int MINIMUM ( int A [], int n ) { int min = A [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( min > A [ i ]) { min = A [ i ]; } } return min ; } 1 2 3 4 5 6 7 8 9 10 11 12 int MAXIMUM ( int A [], int n ) { int max = A [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( max < A [ i ]) { max = A [ i ]; } } return max ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int second_MINIMUM ( int A [], int n ) { int min = A [ 0 ]; int sub_min = A [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( min > A [ i ]) { sub_min = min ; min = A [ i ]; } } return sub_min ; }","title":"9.1 Minimum and maximum"},{"location":"ch9/readme/#92-selection-in-expected-linear-time","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int PARTITION ( int A [], int p , int r ) { int x = A [ r ]; //pivot int i = p - 1 ; for ( int j = p ; j < r - 1 ; j ++ ) { if ( A [ j ] <= x ) { i ++ ; std :: swap ( A [ i ], A [ j ]); } } std :: swap ( A [ i + 1 ], A [ r ]); return i + 1 ; } int RANDOMIZED_SELECT ( int A [], int p , int r , int i ) { if ( p == r ) return A [ p ]; int q = PARTITION ( A , p , r ); int k = q - p + 1 ; if ( i - 1 == k ) return A [ q ]; else if ( i < k ) return RANDOMIZED_SELECT ( A , p , q - 1 , i ); else return RANDOMIZED_SELECT ( A , q + 1 , r , i - k ); }","title":"9.2 Selection in expected linear time"},{"location":"ch9/readme/#93-selection-in-worst-case-linear-time","text":"Median of medians https://en.wikipedia.org/wiki/Median_of_medians Divide the n elements of the input array into bn=5c groups of 5 elements each and at most one group made up of the remaining n mod 5 elements. Find the median of each of the dn=5e groups by first insertion-sorting the elements of each group (of which there are at most 5) and then picking the median from the sorted list of group elements. Use SELECT recursively to find the median x of the dn=5e medians found in step 2. (If there are an even number of medians, then by our convention, x is the lower median.) Partition the input array around the median-of-medians x using the modified version of PARTITION. Let k be one more than the number of elements on the low side of the partition, so that x is the kth smallest element and there are n\u0005k elements on the high side of the partition. If i D k, then return x. Otherwise, use SELECT recursively to find the i th smallest element on the low side if i < k, or the .i \u0005 k/th smallest element on the high side if i > k. https://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array-set-3-worst-case-linear-time/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 // C++ implementation of worst case linear time algorithm // to find k'th smallest element #include <iostream> #include <algorithm> #include <climits> using namespace std ; int partition ( int arr [], int l , int r , int k ); // A simple function to find median of arr[]. This is called // only for an array of size 5 in this program. int findMedian ( int arr [], int n ) { sort ( arr , arr + n ); // Sort the array return arr [ n / 2 ]; // Return middle element } // Returns k'th smallest element in arr[l..r] in worst case // linear time. ASSUMPTION: ALL ELEMENTS IN ARR[] ARE DISTINCT int kthSmallest ( int arr [], int l , int r , int k ) { // If k is smaller than number of elements in array if ( k > 0 && k <= r - l + 1 ) { int n = r - l + 1 ; // Number of elements in arr[l..r] // Divide arr[] in groups of size 5, calculate median // of every group and store it in median[] array. int i ; int * median = new int [( n + 4 ) / 5 ]; // There will be floor((n+4)/5) groups; for ( i = 0 ; i < n / 5 ; i ++ ) median [ i ] = findMedian ( arr + l + i * 5 , 5 ); if ( i * 5 < n ) //For last group with less than 5 elements { median [ i ] = findMedian ( arr + l + i * 5 , n % 5 ); i ++ ; } // Find median of all medians using recursive call. // If median[] has only one element, then no need // of recursive call int medOfMed = ( i == 1 ) ? median [ i - 1 ] : kthSmallest ( median , 0 , i - 1 , i / 2 ); // Partition the array around a random element and // get position of pivot element in sorted array int pos = partition ( arr , l , r , medOfMed ); delete [] median ; // If position is same as k if ( pos - l == k - 1 ) return arr [ pos ]; if ( pos - l > k - 1 ) // If position is more, recur for left return kthSmallest ( arr , l , pos - 1 , k ); // Else recur for right subarray return kthSmallest ( arr , pos + 1 , r , k - pos + l - 1 ); } // If k is more than number of elements in array return INT_MAX ; } void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } // It searches for x in arr[l..r], and partitions the array // around x. int partition ( int arr [], int l , int r , int x ) { // Search for x in arr[l..r] and move it to end int i ; for ( i = l ; i < r ; i ++ ) if ( arr [ i ] == x ) break ; swap ( & arr [ i ], & arr [ r ]); // Standard partition algorithm i = l ; for ( int j = l ; j <= r - 1 ; j ++ ) { if ( arr [ j ] <= x ) { swap ( & arr [ i ], & arr [ j ]); i ++ ; } } swap ( & arr [ i ], & arr [ r ]); return i ; } // Driver program to test above methods int main () { int arr [] = { 12 , 3 , 5 , 7 , 4 , 19 , 26 }; int n = sizeof ( arr ) / sizeof ( arr [ 0 ]), k = 5 ; cout << \"K'th smallest element is \" << kthSmallest ( arr , 0 , n - 1 , k ); return 0 ; }","title":"9.3 Selection in worst-case linear time"},{"location":"sort/nlogn/","text":"merge sort 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 void MERGE ( int A [], int p , int q , int r ) { int n_1 = q - p + 1 ; int n_2 = r - q ; int * L = new int [ n_1 + 2 ]; int * R = new int [ n_2 + 2 ]; for ( int i = 1 ; i <= n_1 ; i ++ ) { L [ i ] = A [ p + i - 1 ]; } for ( int j = 1 ; j <= n_2 ; j ++ ) { R [ j ] = A [ q + j ]; } L [ n_1 + 1 ] = 10000000 ; R [ n_2 + 1 ] = 10000000 ; int i = 1 ; int j = 1 ; for ( int k = p ; k <= r ; k ++ ) { if ( L [ i ] <= R [ j ]) { A [ k ] = L [ i ]; i ++ ; } else { A [ k ] = R [ j ]; j ++ ; } } delete [] L ; delete [] R ; } void MERGE_SORT ( int A [], int p , int r ) { if ( p < r ) { int q = ( p + r ) / 2 ; MERGE_SORT ( A , p , q ); MERGE_SORT ( A , q + 1 , r ); MERGE ( A , p , q , r ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include <queue> template < typename T > void mergesort ( T a [], int low , int high ) { int pivot ; if ( low < high ) { pivot = ( low + high ) / 2 ; mergesort ( a , low , pivot ); mergesort ( a , pivot + 1 , high ); int i = low , j = pivot + 1 ; queue < int > arr ; while (( i <= pivot ) && ( j <= high )) { if ( a [ i ] <= a [ j ]) { arr . push ( a [ i ]); i ++ ; } else { arr . push ( a [ j ]); j ++ ; } } while ( i <= pivot ) { arr . push ( a [ i ]); i ++ ; } while ( j <= high ) { arr . push ( a [ j ]); j ++ ; } for ( int i = low ; i <= high ; i ++ ) { a [ i ] = arr . front (); arr . pop (); } } } quick sort 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template < typename T > void quicksort ( T A [], int start , int end ) { if ( start < end ) { int x = A [ end ]; int i = start - 1 ; for ( int j = start ; j < end - 1 ; j ++ ) { if ( A [ j ] <= x ) { i ++ ; swap ( A [ i ], A [ j ]); } } swap ( A [ i + 1 ], A [ end ]); int q = i + 1 ; quicksort ( A , start , q - 1 ); quicksort ( A , q + 1 , end ); } return ; } shell sort \uc0bd\uc785 \uc815\ub82c\uc758 \uc751\uc6a9\ud310 $h = 3h' +1$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 template < typename T > void shell_sort ( T a [], int num ) { int h = 1 ; while ( h < num / 2 ) { h = 3 * h + 1 ; } while ( h > 1 ) { h = h / 3 ; for ( int i = h ; i < num ; i ++ ) { T item = a [ i ]; int j = i - h ; while ( j >= 0 && item < a [ j ]) { a [ j + h ] = a [ j ]; j = j - h ; } a [ j + h ] = item ; } } } HEAP SORT parent\ub294 \uc2e4\uc81c\ub85c \uc0ac\uc6a9\ud558\uc9c0\ub294 \uc54a\uc74c \uc2e4\uc81c \uacfc\uc815\uc740 MAX_HEAPIFY\uc640HEAPSORT \ub450\uac1c\ub85c \ub098\ud0c0\ub0bc\uc218\uc788\uc74c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 int parent ( int i ) { return i / 2 ; } int left ( int i ) { return 2 * i ; } int right ( int i ) { return 2 * i + 1 ; } void MAX_HEAPIFY ( int A [], int i , int heapsize ) //I\uc778\ub371\uc2a4\uc758 \ub178\ub4dc\uac00 \uc790\uc2dd \ub178\ub4dc\ubcf4\ub2e4 \uc791\uc744 \ub54c \uc774\ub97c \ubc11\uc73c\ub85c \ub0b4\ub824 \ud799\ud2b8\ub9ac \uad6c\uc870\ub97c \ub9cc\ub4e0\ub2e4 { int l = left ( i ); int r = right ( i ); int largest ; if ( l <= heapsize && A [ l ] > A [ i ]) { largest = l ; } else { largest = i ; } if ( r <= heapsize && A [ r ] > A [ largest ]) { largest = r ; } if ( largest != i ) { swap ( A [ i ], A [ largest ]); MAX_HEAPIFY ( A , largest , heapsize ); } } void BUILD_MAX_HEAP ( int A [], int n ) //\uc804\uccb4 \ubc30\uc5f4\uc744 \ud799\ud2b8\ub9ac\ub85c \ub098\ud0c0\ub0b4\uae30 \uc704\ud55c \ud568\uc218 { int heapsize = n ; for ( int i = n / 2 ; i >= 1 ; i -- ) { MAX_HEAPIFY ( A , i , heapsize ); } } void HEAPSORT ( int A [], int size ) { int * B = A - 1 ; //C\uc5d0 \ub9de\uac8c \uc778\ub371\uc2a4\uac12\uc744 \ud558\ub098\uc529 \ub0b4\ub9b0\ub2e4 BUILD_MAX_HEAP ( B , size ); int heapsize = size ; for ( int i = size ; i > 0 ; i -- ) { swap ( B [ 1 ], B [ i ]); heapsize -- ; MAX_HEAPIFY ( B , 1 , heapsize ); } }","title":"nlogn"},{"location":"sort/nlogn/#merge-sort","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 void MERGE ( int A [], int p , int q , int r ) { int n_1 = q - p + 1 ; int n_2 = r - q ; int * L = new int [ n_1 + 2 ]; int * R = new int [ n_2 + 2 ]; for ( int i = 1 ; i <= n_1 ; i ++ ) { L [ i ] = A [ p + i - 1 ]; } for ( int j = 1 ; j <= n_2 ; j ++ ) { R [ j ] = A [ q + j ]; } L [ n_1 + 1 ] = 10000000 ; R [ n_2 + 1 ] = 10000000 ; int i = 1 ; int j = 1 ; for ( int k = p ; k <= r ; k ++ ) { if ( L [ i ] <= R [ j ]) { A [ k ] = L [ i ]; i ++ ; } else { A [ k ] = R [ j ]; j ++ ; } } delete [] L ; delete [] R ; } void MERGE_SORT ( int A [], int p , int r ) { if ( p < r ) { int q = ( p + r ) / 2 ; MERGE_SORT ( A , p , q ); MERGE_SORT ( A , q + 1 , r ); MERGE ( A , p , q , r ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include <queue> template < typename T > void mergesort ( T a [], int low , int high ) { int pivot ; if ( low < high ) { pivot = ( low + high ) / 2 ; mergesort ( a , low , pivot ); mergesort ( a , pivot + 1 , high ); int i = low , j = pivot + 1 ; queue < int > arr ; while (( i <= pivot ) && ( j <= high )) { if ( a [ i ] <= a [ j ]) { arr . push ( a [ i ]); i ++ ; } else { arr . push ( a [ j ]); j ++ ; } } while ( i <= pivot ) { arr . push ( a [ i ]); i ++ ; } while ( j <= high ) { arr . push ( a [ j ]); j ++ ; } for ( int i = low ; i <= high ; i ++ ) { a [ i ] = arr . front (); arr . pop (); } } }","title":"merge sort"},{"location":"sort/nlogn/#quick-sort","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template < typename T > void quicksort ( T A [], int start , int end ) { if ( start < end ) { int x = A [ end ]; int i = start - 1 ; for ( int j = start ; j < end - 1 ; j ++ ) { if ( A [ j ] <= x ) { i ++ ; swap ( A [ i ], A [ j ]); } } swap ( A [ i + 1 ], A [ end ]); int q = i + 1 ; quicksort ( A , start , q - 1 ); quicksort ( A , q + 1 , end ); } return ; }","title":"quick sort"},{"location":"sort/nlogn/#shell-sort","text":"\uc0bd\uc785 \uc815\ub82c\uc758 \uc751\uc6a9\ud310 $h = 3h' +1$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 template < typename T > void shell_sort ( T a [], int num ) { int h = 1 ; while ( h < num / 2 ) { h = 3 * h + 1 ; } while ( h > 1 ) { h = h / 3 ; for ( int i = h ; i < num ; i ++ ) { T item = a [ i ]; int j = i - h ; while ( j >= 0 && item < a [ j ]) { a [ j + h ] = a [ j ]; j = j - h ; } a [ j + h ] = item ; } } }","title":"shell sort"},{"location":"sort/nlogn/#heap-sort","text":"parent\ub294 \uc2e4\uc81c\ub85c \uc0ac\uc6a9\ud558\uc9c0\ub294 \uc54a\uc74c \uc2e4\uc81c \uacfc\uc815\uc740 MAX_HEAPIFY\uc640HEAPSORT \ub450\uac1c\ub85c \ub098\ud0c0\ub0bc\uc218\uc788\uc74c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 int parent ( int i ) { return i / 2 ; } int left ( int i ) { return 2 * i ; } int right ( int i ) { return 2 * i + 1 ; } void MAX_HEAPIFY ( int A [], int i , int heapsize ) //I\uc778\ub371\uc2a4\uc758 \ub178\ub4dc\uac00 \uc790\uc2dd \ub178\ub4dc\ubcf4\ub2e4 \uc791\uc744 \ub54c \uc774\ub97c \ubc11\uc73c\ub85c \ub0b4\ub824 \ud799\ud2b8\ub9ac \uad6c\uc870\ub97c \ub9cc\ub4e0\ub2e4 { int l = left ( i ); int r = right ( i ); int largest ; if ( l <= heapsize && A [ l ] > A [ i ]) { largest = l ; } else { largest = i ; } if ( r <= heapsize && A [ r ] > A [ largest ]) { largest = r ; } if ( largest != i ) { swap ( A [ i ], A [ largest ]); MAX_HEAPIFY ( A , largest , heapsize ); } } void BUILD_MAX_HEAP ( int A [], int n ) //\uc804\uccb4 \ubc30\uc5f4\uc744 \ud799\ud2b8\ub9ac\ub85c \ub098\ud0c0\ub0b4\uae30 \uc704\ud55c \ud568\uc218 { int heapsize = n ; for ( int i = n / 2 ; i >= 1 ; i -- ) { MAX_HEAPIFY ( A , i , heapsize ); } } void HEAPSORT ( int A [], int size ) { int * B = A - 1 ; //C\uc5d0 \ub9de\uac8c \uc778\ub371\uc2a4\uac12\uc744 \ud558\ub098\uc529 \ub0b4\ub9b0\ub2e4 BUILD_MAX_HEAP ( B , size ); int heapsize = size ; for ( int i = size ; i > 0 ; i -- ) { swap ( B [ 1 ], B [ i ]); heapsize -- ; MAX_HEAPIFY ( B , 1 , heapsize ); } }","title":"HEAP SORT"},{"location":"sort/on/","text":"COUNTING SORT persude code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 COUNTING - SORT ( A , B , k ) let C [ 0..k ] be a new array for i = 0 to k C [ i ] = 0 for j = 1 to A . length C [ A[j ] ] = C [ A[j ] ] + 1 // C [ i ] now contains the number of elements equal to i . for i = 1 to k C [ i ] = C [ i ] + C [ i-1 ] // C [ i ] now contains the number of elements less than or equal to i . for j = A . ength downto 1 B [ C[A[j ] ]] = A [ j ] C [ A[j ] ] = C [ A[j ] ] - 1 \ubd84\ud3ec\uac12\uc774 \uc591\uc218\uc778\uacbd\uc6b0\uc5d0\ub9cc \uc801\uc6a9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void COUNTING_SORT ( int A [] , int n , int k ) // A\uc758 \uc218 n , k : \uc22b\uc790\ubc94\uc704 { int * C = new int [ k ] ; int * B = new int [ n ] ; for ( int i = 0 ; i < k ; i ++ ) { C [ i ] = 0 ; } for ( int j = 0 ; j < n ; j ++ ) { C [ A[j ] ] = C [ A[j ] ] + 1 ; } for ( int i = 1 ; i < k ; i ++ ) { C [ i ] = C [ i ] + C [ i - 1 ] ; } for ( int j = n - 1 ; j >= 0 ; j --) { B [ C[A[j ] ] - 1 ] = A [ j ] ; C [ A[j ] ] = C [ A[j ] ] - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { A [ i ] = B [ i ] ; } delete [] C ; delete [] B ; }","title":true},{"location":"sort/on/#counting-sort","text":"persude code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 COUNTING - SORT ( A , B , k ) let C [ 0..k ] be a new array for i = 0 to k C [ i ] = 0 for j = 1 to A . length C [ A[j ] ] = C [ A[j ] ] + 1 // C [ i ] now contains the number of elements equal to i . for i = 1 to k C [ i ] = C [ i ] + C [ i-1 ] // C [ i ] now contains the number of elements less than or equal to i . for j = A . ength downto 1 B [ C[A[j ] ]] = A [ j ] C [ A[j ] ] = C [ A[j ] ] - 1 \ubd84\ud3ec\uac12\uc774 \uc591\uc218\uc778\uacbd\uc6b0\uc5d0\ub9cc \uc801\uc6a9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void COUNTING_SORT ( int A [] , int n , int k ) // A\uc758 \uc218 n , k : \uc22b\uc790\ubc94\uc704 { int * C = new int [ k ] ; int * B = new int [ n ] ; for ( int i = 0 ; i < k ; i ++ ) { C [ i ] = 0 ; } for ( int j = 0 ; j < n ; j ++ ) { C [ A[j ] ] = C [ A[j ] ] + 1 ; } for ( int i = 1 ; i < k ; i ++ ) { C [ i ] = C [ i ] + C [ i - 1 ] ; } for ( int j = n - 1 ; j >= 0 ; j --) { B [ C[A[j ] ] - 1 ] = A [ j ] ; C [ A[j ] ] = C [ A[j ] ] - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { A [ i ] = B [ i ] ; } delete [] C ; delete [] B ; }","title":"COUNTING SORT"},{"location":"sort/radix/","text":"//not my code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 #include < iostream > #include < utility > #include < cstdio > using namespace std ; int b [] = { 12 , 10 , 43 , 43 , 23 , 123 , 56 , 45 , 123 , 56 , 56 , 98 , 45 , 123 , 56 , 98 , 41 , 90 , 24 , 45 } ; // , - 78 , 45 , /** * @data \uc815\uc218 \ubc30\uc5f4 * @size data\uc758 \uc815\uc218\ub4e4\uc758 \uac1c\uc218 * @p \uc22b\uc790\uc758 \ucd5c\ub300 \uc790\ub9ac\uc218 * @k \uae30\uc218(10\uc9c4\ubc95\uc744 \uc0ac\uc6a9\ud55c\ub2e4\uba74 10) */ void rxSort ( int * data , int size , int p , int k ) { int * counts , // \ud2b9\uc815 \uc790\ub9ac\uc5d0\uc11c \uc22b\uc790\ub4e4\uc758 \uce74\uc6b4\ud2b8 * temp ; // \uc815\ub82c\ub41c \ubc30\uc5f4\uc744 \ub2f4\uc744 \uc784\uc2dc \uc7a5\uc18c int index , pval , i , j , n ; // \uba54\ubaa8\ub9ac \ud560\ub2f9 if (( counts = ( int * ) malloc ( k * sizeof ( int ))) == NULL ) return ; if (( temp = ( int * ) malloc ( size * sizeof ( int ))) == NULL ) return ; for ( n = 0 ; n < p ; n ++ ) { // 1 \uc758 \uc790\ub9ac , 10 \uc758\uc790\ub9ac , 100 \uc758 \uc790\ub9ac \uc21c\uc73c\ub85c \uc9c4\ud589 for ( i = 0 ; i < k ; i ++ ) counts [ i ] = 0 ; // \ucd08\uae30\ud654 // \uc704\uce58\uac12 \uacc4\uc0b0 . // n : 0 => 1 , 1 => 10 , 2 => 100 pval = ( int ) pow (( double ) k , ( double ) n ); // \uac01 \uc22b\uc790\uc758 \ubc1c\uc0dd\ud69f\uc218\ub97c \uc13c\ub2e4 . for ( j = 0 ; j < size ; j ++ ) { // 253 \uc774\ub77c\ub294 \uc22b\uc790\ub77c\uba74 // n : 0 => 3 , 1 => 5 , 2 => 2 index = ( int )( data [ j ] / pval ) % k ; counts [ index ] = counts [ index ] + 1 ; } // \uce74\uc6b4\ud2b8 \ub204\uc801\ud569\uc744 \uad6c\ud55c\ub2e4 . \uacc4\uc218\uc815\ub82c\uc744 \uc704\ud574\uc11c . for ( i = 1 ; i < k ; i ++ ) { counts [ i ] = counts [ i ] + counts [ i - 1 ] ; } // \uce74\uc6b4\ud2b8\ub97c \uc0ac\uc6a9\ud574 \uac01 \ud56d\ubaa9\uc758 \uc704\uce58\ub97c \uacb0\uc815\ud55c\ub2e4 . // \uacc4\uc218\uc815\ub82c \ubc29\uc2dd for ( j = size - 1 ; j >= 0 ; j --) { // \ub4a4\uc5d0\uc11c\ubd80\ud130 \uc2dc\uc791 index = ( int )( data [ j ] / pval ) % k ; temp [ counts[index ] - 1 ] = data [ j ] ; counts [ index ] = counts [ index ] - 1 ; // \ud574\ub2f9 \uc22b\uc790 \uce74\uc6b4\ud2b8\ub97c 1 \uac10\uc18c } // \uc784\uc2dc \ub370\uc774\ud130 \ubcf5\uc0ac memcpy ( data , temp , size * sizeof ( int )); } free ( counts ); free ( temp ); } void COUNTING_SORT ( int A [] , int n , int k ) // A\uc758 \uc218 n , k : \uc22b\uc790\ubc94\uc704 { int * C = new int [ k ] ; int * B = new int [ n ] ; for ( int i = 0 ; i < k ; i ++ ) { C [ i ] = 0 ; } for ( int j = 0 ; j < n ; j ++ ) { C [ A[j ] ] = C [ A[j ] ] + 1 ; } for ( int i = 1 ; i < k ; i ++ ) { C [ i ] = C [ i ] + C [ i - 1 ] ; } for ( int j = n - 1 ; j >= 0 ; j --) { B [ C[A[j ] ] - 1 ] = A [ j ] ; C [ A[j ] ] = C [ A[j ] ] - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { A [ i ] = B [ i ] ; } delete [] C ; delete [] B ; } void print ( int A [] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { cout << A [ i ] << ' ' ; } cout << '\\n' ; } int main () // \u00ad { int num = sizeof ( b ) / sizeof ( int ); print ( b , num ); COUNTING_SORT ( b , num , 150 ); print ( b , num ); return 0 ; }","title":"Radix"},{"location":"sort/readme/","text":"simple sort $O(n^2)$ bubble (chapter2 Problem) selection insertion (chapter 2.1) $O(n \\log n)$ merge (chapter 2.3) quick (chapter 7) chapter 7\uc758 problem\uc740 \uc5ec\uae30 shell heap (chapter 6) $O(n)$ (chapter 8) radix counting bucket","title":"Readme"},{"location":"sort/readme/#simple-sort-on2","text":"bubble (chapter2 Problem) selection insertion (chapter 2.1)","title":"simple sort $O(n^2)$"},{"location":"sort/readme/#on-log-n","text":"merge (chapter 2.3) quick (chapter 7) chapter 7\uc758 problem\uc740 \uc5ec\uae30 shell heap (chapter 6)","title":"$O(n \\log n)$"},{"location":"sort/readme/#on-chapter-8","text":"radix counting bucket","title":"$O(n)$ (chapter 8)"},{"location":"sort/simple_sort/","text":"swap\ud568\uc218\ub294 \uc788\ub294\uac78 \uc501\ub2c8\ub2e4 swap \ud568\uc218\ub294 \ub2e4\uc74c \ub77c\uc774\ube0c\ub7ec\ub9ac\uc5d0 \uc788\uc2b5\ub2c8\ub2e4. 1 #include<utility> bubble \ubaa8\ub4e0 \uac12\uc740 \ube44\uad50\ud574\uc11c \uc2a4\uc651\ud55c\ub2e4. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template < typename T > void buble_sort ( T a [] , int num ) { for ( int i = 0 ; i < num - 1 ; i ++ ) { for ( int j = 0 ; j < num - i - 1 ; j ++ ) { if ( a [ j ] > a [ j + 1 ] ) { swap ( a [ j ] , a [ j + 1 ] ); } } } } selection_sort \uac00\uc7a5\uc791\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ub9e8\ubc11\uc73c\ub85c \ub123\ub294\ub2e4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template < typename T > void selection_sort ( T a [] , int num ) { for ( int i = 0 ; i < num - 1 ; i ++ ) { int Minindex = i ; for ( int j = i + 1 ; j < num ; j ++ ) { if ( a [ j ] < a [ Minindex ] ) { Minindex = j ; } } swap ( a [ Minindex ] , a [ i ] ); } return ; } insertion_sort \uc0bd\uc785\uc815\ub82c, \ub4a4\uc758 \uac12\uc744 \ubc00\uc5b4\ub0b4\uace0 \uac12\uc744 \ub123\ub294\ub2e4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template < typename T > void insertion_sort ( T a [] , int num ) { for ( int i = 1 ; i < num ; i ++ ) { T item = a [ i ] ; int j = i ; while ( --j >= 0 && item < a[j]) { a [ j + 1 ] = a [ j ] ; } a [ ++j ] = item ; } } \uc2e4\uc81c \uc0bd\uc785\uc744 \ud588\uc744\ub54c, 1 2 3 4 5 6 7 8 9 10 11 12 template < typename T > int sorting_insertion ( T a [], int num , T item ) { int j = num ; while ( -- j >= 0 && item < a [ j ]) { a [ j + 1 ] = a [ j ]; } a [ ++ j ] = item ; return num + 1 ; }","title":"simple_sort"},{"location":"sort/simple_sort/#bubble","text":"\ubaa8\ub4e0 \uac12\uc740 \ube44\uad50\ud574\uc11c \uc2a4\uc651\ud55c\ub2e4. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template < typename T > void buble_sort ( T a [] , int num ) { for ( int i = 0 ; i < num - 1 ; i ++ ) { for ( int j = 0 ; j < num - i - 1 ; j ++ ) { if ( a [ j ] > a [ j + 1 ] ) { swap ( a [ j ] , a [ j + 1 ] ); } } } }","title":"bubble"},{"location":"sort/simple_sort/#selection_sort","text":"\uac00\uc7a5\uc791\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ub9e8\ubc11\uc73c\ub85c \ub123\ub294\ub2e4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template < typename T > void selection_sort ( T a [] , int num ) { for ( int i = 0 ; i < num - 1 ; i ++ ) { int Minindex = i ; for ( int j = i + 1 ; j < num ; j ++ ) { if ( a [ j ] < a [ Minindex ] ) { Minindex = j ; } } swap ( a [ Minindex ] , a [ i ] ); } return ; }","title":"selection_sort"},{"location":"sort/simple_sort/#insertion_sort","text":"\uc0bd\uc785\uc815\ub82c, \ub4a4\uc758 \uac12\uc744 \ubc00\uc5b4\ub0b4\uace0 \uac12\uc744 \ub123\ub294\ub2e4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template < typename T > void insertion_sort ( T a [] , int num ) { for ( int i = 1 ; i < num ; i ++ ) { T item = a [ i ] ; int j = i ; while ( --j >= 0 && item < a[j]) { a [ j + 1 ] = a [ j ] ; } a [ ++j ] = item ; } } \uc2e4\uc81c \uc0bd\uc785\uc744 \ud588\uc744\ub54c, 1 2 3 4 5 6 7 8 9 10 11 12 template < typename T > int sorting_insertion ( T a [], int num , T item ) { int j = num ; while ( -- j >= 0 && item < a [ j ]) { a [ j + 1 ] = a [ j ]; } a [ ++ j ] = item ; return num + 1 ; }","title":"insertion_sort"}]}