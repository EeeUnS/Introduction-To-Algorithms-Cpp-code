# All-Pairs Shortest Paths


```
const int NIL = 0;

void PRINT_ALL_PAIRS_SHORTEST_PATH(std::vector<std::vector<int>> pi, int i, int j)
{
	if (i == j)
		std::cout << ' ' << i << ' ';
	else if (pi[i][j] == NIL)
	{
		std::cout << "no path from " << i << " to " << j << " exists" << std::endl;
	}
	else
	{
		PRINT_ALL_PAIRS_SHORTEST_PATH(pi, i, pi[i][j]);
		std::cout << ' ' << j << ' ';
	}
}
```

```

#include<iomanip>
void print_matrix(std::vector < std::vector<int>>& m)
{
	const int n = m.size();

	for (int i = 1; i < n; i++)
	{
		for (int j = 1; j < n; j++)
		{
			if(m[i][j] == INF)
				std::cout << "INF" << ' ';
			else
				std::cout <<std::setw(3)<< m[i][j] << ' ';
			
		}
		std::cout << '\n';
	}
	std::cout << '\n' << '\n';
}

```


# 25.1 Shortest paths and matrix multiplication

O(V^3)
```

std::vector<std::vector<int>> EXTEND_SHORTEST_PATHS(std::vector<std::vector<int>>& L, std::vector<std::vector<int>>& W)
{
	const int n = L.size();


	std::vector<std::vector<int>> L_prime;
	L_prime.assign(n, std::vector<int>(n, INF));
	for(int i = 1; i < n; i++)
	{
		for (int j = 1; j < n; j++)
		{

			for (int k = 1; k < n; k++)
			{
				L_prime[i][j] = (L_prime[i][j] < L[i][k] + W[k][j] ?  L_prime[i][j] : L[i][k] + W[k][j]);
			}

		}
	}
	return L_prime;
}
```


총 O(V^4)
```

//nxn 1~n
std::vector<std::vector<int>>SLOW_ALL_PAIRS_SHORTEST_PATHS(std::vector<std::vector<int>>& W)
{
	const int n = W.size() - 1;

	std::vector<std::vector<std::vector<int>>> L;
	L.resize(n+1);
	for (int i = 0 ; i < n+1;i++)
	{
		L[i].resize(n+1);
		for (int j = 0; j < n + 1; j++)
		{
			L[i][j].resize(n + 1);
		}
	}
	L[1] = W;
	for (int m = 2; m < n; m++)
	{
		L[m] = EXTEND_SHORTEST_PATHS(L[m - 1], W);
	}
	return L[n-1];
}
```



총 O(V^3log(V))
```
std::vector<std::vector<int>>FASTER_ALL_PAIRS_SHORTEST_PATHS(std::vector<std::vector<int>>& W)
{
	const int n = W.size() - 1;

	std::vector<std::vector<std::vector<int>>> L;
	int a = 1;
	while (a < n)
	{
		a = a * 2;
	}


	L.resize(a+1);
	for (int i = 0; i <= a ; i++)
	{
		L[i].resize(n+1);
		for (int j = 0; j <= n ; j++)
		{
			L[i][j].resize(n + 1);
		}
	}
	L[1] = W;
	int m = 1;
	while(m < n -1)
	{
		L[2*m] = EXTEND_SHORTEST_PATHS(L[m], L[m]);
		m = m*2;
	}
	return  L[m];
}
```





//25.1-6
```
void set_pi(std::vector<std::vector<int>> &W, std::vector<std::vector<int >> &L, std::vector<std::vector<int>>& pi)
{
	const int n = L.size();
	for (int i = 1; i < n; i++)
	{
		for (int j = 1; j < n ;j++)
		{
			for (int k = 1; k < n; k++)
			{
				if ((L[i][j] - L[i][k]) == W[k][j])
				{
					if (W[k][j] != 0 && i!=j)
					{
						pi[i][j] = k;
					}
				}
			}
		}
	}
}
```

//25.7
전체 다시 짜기
```

//25.1-7
void EXTEND_SHORTEST_PATHS_pi(std::vector<std::vector<int>>& L, 
	std::vector<std::vector<int>>& W, std::vector<std::vector<int>>& pi,
	std::vector<std::vector<int>>* __L , std::vector<std::vector<int>> *___pi
)
{
	const int n = L.size();
	//std::vector<std::vector<int>> L_prime;
	//L_prime.assign(n, std::vector<int>(n, INF));
	for (int i = 1; i < n; i++)
	{
		for (int j = 1; j < n; j++)
		{

			for (int k = 1; k < n; k++)
			{
				if ((*__L)[i][j] > L[i][k] + W[k][j])
				{
					(*__L)[i][j] = (L[i][k] + W[k][j]);
					(*___pi)[i][j] = k;
				}
			}

		}
	}
	//return L_prime;
}

//nxn 1~n
void SLOW_ALL_PAIRS_SHORTEST_PATHS_pi(std::vector<std::vector<int>>& W, 
	std::vector<std::vector<int>> *__pi, std::vector<std::vector<int>> *__L)
{
	const int n = W.size() - 1;

	std::vector<std::vector<std::vector<int>>> L;
	std::vector<std::vector<std::vector<int>>> pi;
	L.resize(n + 1);
	pi.resize(n + 1);
	for (int i = 0; i < n + 1; i++)
	{
		pi[i].assign(n + 1, std::vector<int>(n + 1, INF));
		L[i].assign(n + 1, std::vector<int>(n + 1, INF));
	}
	L[1] = W;
	for (int m = 2; m < n; m++)
	{
		EXTEND_SHORTEST_PATHS_pi(L[m - 1], W, pi[m - 1], &L[m], &pi[m]);
	}
	__L->swap(L[n - 1]);
	__pi->swap(pi[n - 1]);
}

```


25.1-8
space requirement Theta(n^2)
```
std::vector<std::vector<int>>FASTER_ALL_PAIRS_SHORTEST_PATHS(std::vector<std::vector<int>>& W)
{
	const int n = W.size() - 1;

	std::vector<std::vector<int>> A, B = W;
	A.resize(n + 1);

	for (int j = 0; j <= n; j++)
	{
		A[j].resize(n + 1);
	}

	int m = 1;

	while (m < n - 1)
	{
		A = EXTEND_SHORTEST_PATHS(B, B);
		m = m * 2;
		if (m >= n - 1)
		{
			return A;
		}

		B = EXTEND_SHORTEST_PATHS(A, A);
		m = m * 2;
	}
	return  B;
}

```


//25.1-9  25.1-8에 이어서.
no consider overflow;


std::vector<std::vector<int>>FASTER_ALL_PAIRS_SHORTEST_PATHS(std::vector<std::vector<int>>& W)
{
	const int n = W.size() - 1;

	std::vector<std::vector<int>> A = W, B = W, C = W ,D = W;
	A.resize(n + 1);
	for (int j = 0; j <= n; j++)
	{
		A[j].resize(n + 1);
	}

	int m = 1;

	while (1)
	{
		A = EXTEND_SHORTEST_PATHS(B, B);
		m = m * 2;
		if (m > n - 1)
		{
			C = A;
			break;
		}

		B = EXTEND_SHORTEST_PATHS(A, A);
		m = m * 2;
		if (m > n - 1)
		{
			C = B;
			break;
		}
	}
	D = EXTEND_SHORTEST_PATHS(C, C);
	
	print_matrix(C);
	print_matrix(D);


	bool chk_nwc = 0;
	for (int i = 1; i <= n && !chk_nwc; i++)
	{
		for (int j = 1; j <= n && !chk_nwc; j++)
		{
			if (C[i][j] != D[i][j])
			{
				chk_nwc = true;
			}
		}
	}

	if (chk_nwc)
		std::cout << "the input graph contains a negative-weight cycle" << std::endl;

	return C;
}


