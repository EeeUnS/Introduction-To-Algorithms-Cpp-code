# All-Pairs Shortest Paths


```
const int NIL = 0;

void PRINT_ALL_PAIRS_SHORTEST_PATH(std::vector<std::vector<int>> pi, int i, int j)
{
	if (i == j)
		std::cout << ' ' << i << ' ';
	else if (pi[i][j] == NIL)
	{
		std::cout << "no path from " << i << " to " << j << " exists" << std::endl;
	}
	else
	{
		PRINT_ALL_PAIRS_SHORTEST_PATH(pi, i, pi[i][j]);
		std::cout << ' ' << j << ' ';
	}
}
```

```

#include<iomanip>
void print_matrix(std::vector < std::vector<int>>& m)
{
	const int n = m.size();

	for (int i = 1; i < n; i++)
	{
		for (int j = 1; j < n; j++)
		{
			if(m[i][j] == INF)
				std::cout << "INF" << ' ';
			else
				std::cout <<std::setw(3)<< m[i][j] << ' ';
			
		}
		std::cout << '\n';
	}
	std::cout << '\n' << '\n';
}

```


# 25.1 Shortest paths and matrix multiplication

O(V^3)
```

std::vector<std::vector<int>> EXTEND_SHORTEST_PATHS(std::vector<std::vector<int>>& L, std::vector<std::vector<int>>& W)
{
	const int n = L.size();


	std::vector<std::vector<int>> L_prime;
	L_prime.assign(n, std::vector<int>(n, INF));
	for(int i = 1; i < n; i++)
	{
		for (int j = 1; j < n; j++)
		{

			for (int k = 1; k < n; k++)
			{
				L_prime[i][j] = (L_prime[i][j] < L[i][k] + W[k][j] ?  L_prime[i][j] : L[i][k] + W[k][j]);
			}

		}
	}
	return L_prime;
}
```


총 O(V^4)
```

//nxn 1~n
std::vector<std::vector<int>>SLOW_ALL_PAIRS_SHORTEST_PATHS(std::vector<std::vector<int>>& W)
{
	const int n = W.size() - 1;

	std::vector<std::vector<std::vector<int>>> L;
	L.resize(n+1);
	for (int i = 0 ; i < n+1;i++)
	{
		L[i].resize(n+1);
		for (int j = 0; j < n + 1; j++)
		{
			L[i][j].resize(n + 1);
		}
	}
	L[1] = W;
	for (int m = 2; m < n; m++)
	{
		L[m] = EXTEND_SHORTEST_PATHS(L[m - 1], W);
	}
	return L[n-1];
}
```



총 O(V^3log(V))
```
std::vector<std::vector<int>>FASTER_ALL_PAIRS_SHORTEST_PATHS(std::vector<std::vector<int>>& W)
{
	const int n = W.size() - 1;

	std::vector<std::vector<std::vector<int>>> L;
	int a = 1;
	while (a < n)
	{
		a = a * 2;
	}


	L.resize(a+1);
	for (int i = 0; i <= a ; i++)
	{
		L[i].resize(n+1);
		for (int j = 0; j <= n ; j++)
		{
			L[i][j].resize(n + 1);
		}
	}
	L[1] = W;
	int m = 1;
	while(m < n -1)
	{
		L[2*m] = EXTEND_SHORTEST_PATHS(L[m], L[m]);
		m = m*2;
	}
	return  L[m];
}
```





//25.1-6
```
void set_pi(std::vector<std::vector<int>> &W, std::vector<std::vector<int >> &L, std::vector<std::vector<int>>& pi)
{
	const int n = L.size();
	for (int i = 1; i < n; i++)
	{
		for (int j = 1; j < n ;j++)
		{
			for (int k = 1; k < n; k++)
			{
				if ((L[i][j] - L[i][k]) == W[k][j])
				{
					if (W[k][j] != 0 && i!=j)
					{
						pi[i][j] = k;
					}
				}
			}
		}
	}
}
```

//25.7
전체 다시 짜기
```

//25.1-7
void EXTEND_SHORTEST_PATHS_pi(std::vector<std::vector<int>>& L, 
	std::vector<std::vector<int>>& W, std::vector<std::vector<int>>& pi,
	std::vector<std::vector<int>>* __L , std::vector<std::vector<int>> *___pi
)
{
	const int n = L.size();
	//std::vector<std::vector<int>> L_prime;
	//L_prime.assign(n, std::vector<int>(n, INF));
	for (int i = 1; i < n; i++)
	{
		for (int j = 1; j < n; j++)
		{

			for (int k = 1; k < n; k++)
			{
				if ((*__L)[i][j] > L[i][k] + W[k][j])
				{
					(*__L)[i][j] = (L[i][k] + W[k][j]);
					(*___pi)[i][j] = k;
				}
			}

		}
	}
	//return L_prime;
}

//nxn 1~n
void SLOW_ALL_PAIRS_SHORTEST_PATHS_pi(std::vector<std::vector<int>>& W, 
	std::vector<std::vector<int>> *__pi, std::vector<std::vector<int>> *__L)
{
	const int n = W.size() - 1;

	std::vector<std::vector<std::vector<int>>> L;
	std::vector<std::vector<std::vector<int>>> pi;
	L.resize(n + 1);
	pi.resize(n + 1);
	for (int i = 0; i < n + 1; i++)
	{
		pi[i].assign(n + 1, std::vector<int>(n + 1, INF));
		L[i].assign(n + 1, std::vector<int>(n + 1, INF));
	}
	L[1] = W;
	for (int m = 2; m < n; m++)
	{
		EXTEND_SHORTEST_PATHS_pi(L[m - 1], W, pi[m - 1], &L[m], &pi[m]);
	}
	__L->swap(L[n - 1]);
	__pi->swap(pi[n - 1]);
}

```


25.1-8
space requirement Theta(n^2)
```
std::vector<std::vector<int>>FASTER_ALL_PAIRS_SHORTEST_PATHS(std::vector<std::vector<int>>& W)
{
	const int n = W.size() - 1;

	std::vector<std::vector<int>> A, B = W;
	A.resize(n + 1);

	for (int j = 0; j <= n; j++)
	{
		A[j].resize(n + 1);
	}

	int m = 1;

	while (m < n - 1)
	{
		A = EXTEND_SHORTEST_PATHS(B, B);
		m = m * 2;
		if (m >= n - 1)
		{
			return A;
		}

		B = EXTEND_SHORTEST_PATHS(A, A);
		m = m * 2;
	}
	return  B;
}

```

25.1-9  25.1-8에 이어서.
no consider overflow;

```
std::vector<std::vector<int>>FASTER_ALL_PAIRS_SHORTEST_PATHS(std::vector<std::vector<int>>& W)
{
	const int n = W.size() - 1;

	std::vector<std::vector<int>> A = W, B = W, C = W ,D = W;
	A.resize(n + 1);
	for (int j = 0; j <= n; j++)
	{
		A[j].resize(n + 1);
	}

	int m = 1;

	while (1)
	{
		A = EXTEND_SHORTEST_PATHS(B, B);
		m = m * 2;
		if (m > n - 1)
		{
			C = A;
			break;
		}

		B = EXTEND_SHORTEST_PATHS(A, A);
		m = m * 2;
		if (m > n - 1)
		{
			C = B;
			break;
		}
	}
	D = EXTEND_SHORTEST_PATHS(C, C);
	
	print_matrix(C);
	print_matrix(D);


	bool chk_nwc = 0;
	for (int i = 1; i <= n && !chk_nwc; i++)
	{
		for (int j = 1; j <= n && !chk_nwc; j++)
		{
			if (C[i][j] != D[i][j])
			{
				chk_nwc = true;
			}
		}
	}

	if (chk_nwc)
		std::cout << "the input graph contains a negative-weight cycle" << std::endl;

	return C;
}






# 25.2 The Floyd-Warshall algorithm



n = n+1
```
std::vector<std::vector<int>>FLOYD_WARSHALL(std::vector<std::vector<int>>& W)
{
    const int n = W.size();
    std::vector<std::vector<std::vector<int>>> D;
    D.resize(n);
    for (int i = 0; i < n ; i++)
	{
		D[i].resize(n);
		for (int j = 0; j < n ; j++)
		{
			D[i][j].resize(n);
		}
	}
	D[0] = W;
    for(int k = 1 ; k< n  ;k++)
    {
        for(int i = 1 ; i < n ; i++)
        {
            for(int j = 1 ; j < n ;j++)
            {
                D[k][i][j] = (D[k-1][i][j] < D[k-1][i][k] + D[k-1][k][j] ?  D[k-1][i][j] : D[k-1][i][k] + D[k-1][k][j]);
            }
        }
    }
	return  D[n-1];
}
```



Graph is nxn matrix
```
std::vector<std::vector<int>>TRANSITIVE_CLOSURE(std::vector<std::vector<int>>& G)
{
	const int n = G.size() - 1;
	std::vector<std::vector<std::vector<int>>> T;

	T.resize(n + 1);
	for (int i = 0; i <= n; i++)
	{
		T[i].resize(n + 1);
		for (int j = 0; j <= n; j++)
		{
			T[i][j].resize(n + 1);
		}
	}

	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			if ((i == j) || (G[i][j] != 0))
			{
				T[0][i][j] = 1;

			}
			else
			{
				T[0][i][j] = 0;
			}
		}
	}
	for (int k = 1; k <= n; k++)
	{
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= n; j++)
			{
				T[k][i][j] = T[k - 1][i][j] | (T[k - 1][i][k] & T[k - 1][k][j]);
			}
		}
	}
	return  T[n];
}
```



25.2-3 25.2-4에 이어서.

공간복잡도 O(n^3)
```
std::vector<std::vector<int>>FLOYD_WARSHALL_apostrophe_pi(std::vector<std::vector<int>>& W, std::vector<std::vector<int>>& pi )
{
	const int n = W.size()-1;
	std::vector<std::vector<int>> D = W;
	std::vector<std::vector<std::vector<int>>> pi_prime;

	pi_prime.resize(n + 1);


	for (int k = 0; k <= n; k++)
	{
		pi_prime[k].resize(n + 1);
		for (int i = 0; i <= n; i++)
		{
			pi_prime[k][i].resize(n + 1);
			for (int j = 0; j <= n; j++)
			{
				if ((i == j) || (pi_prime[k][i][j] == INF))
				{
					pi_prime[k][i][j] = NIL;
				}
				else
				{
					pi_prime[k][i][j] = k;
				}
			}
		}
	}


	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			if ((D[i][j] != INF)&&(i != j))
			{
				pi_prime[0][i][j] = i;
			}
		}
	}
	print_matrix(pi_prime[0]);

	for (int k = 1; k <= n; k++)
	{
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= n; j++)
			{
				if (D[i][j] > D[i][k] + D[k][j])
				{
					D[i][j] = D[i][k] + D[k][j];
					pi_prime[k][i][j] = pi_prime[k - 1][k][j];
				}
				else
				{
					pi_prime[k][i][j] = pi_prime[k - 1][i][j];
				}
			}
		}
	}
	pi.swap(pi_prime[n]);
	return  D;
}

```

공간복잡도 O(n^2)
```
std::vector<std::vector<int>>FLOYD_WARSHALL_apostrophe_pi(std::vector<std::vector<int>>& W, std::vector<std::vector<int>>& pi )
{
	const int n = W.size()-1;
	std::vector<std::vector<int>> D = W;
	std::vector<std::vector<int>> pi_prime;

	pi_prime.resize(n + 1);
	for (int i = 1; i <= n; i++)
	{
		pi_prime[i].resize(n + 1);
	}


	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			if ((W[i][j] != INF) && (i != j))
			{
				pi_prime[i][j] = i;
			}
		}
	}
	print_matrix(pi_prime);

	for (int k = 1; k <= n; k++)
	{
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= n; j++)
			{
				if (D[i][j] > D[i][k] + D[k][j])
				{
					D[i][j] = D[i][k] + D[k][j];
					pi_prime[i][j] = pi_prime[k][j];
				}
			}
		}
	}
	pi.swap(pi_prime);
	return  D;
}
```






25.2-4
```
std::vector<std::vector<int>>FLOYD_WARSHALL_apostrophe(std::vector<std::vector<int>>& W)
{
	const int n = W.size();
	std::vector<std::vector<int>> D;
	D.resize(n);
	for (int i = 0; i < n; i++)
	{
		D[i].resize(n);
	}
	D = W;
	for (int k = 1; k < n; k++)
	{
		for (int i = 1; i < n; i++)
		{
			for (int j = 1; j < n; j++)
			{
				D[i][j] = (D[i][j] < D[i][k] + D[k][j] ? D[i][j] : D[i][k] + D[k][j]);
			}
		}
	}
	return  D;
}
```


