# All-Pairs Shortest Paths


```
const int NIL = 0;

void PRINT_ALL_PAIRS_SHORTEST_PATH(std::vector<std::vector<int>> pi, int i, int j)
{
	if (i == j)
		std::cout << ' ' << i << ' ';
	else if (pi[i][j] == NIL)
	{
		std::cout << "no path from " << i << " to " << j << " exists" << std::endl;
	}
	else
	{
		PRINT_ALL_PAIRS_SHORTEST_PATH(pi, i, pi[i][j]);
		std::cout << ' ' << j << ' ';
	}
}
```

```

#include<iomanip>


void print_matrix(std::vector < std::vector<int>>& m)
{
	const int n = m.size();

	for (int i = 1; i < n; i++)
	{
		for (int j = 1; j < n; j++)
		{
			if(m[i][j] == INF)
				std::cout << "INF" << ' ';
			else
				std::cout <<std::setw(3)<< m[i][j] << ' ';
			
		}
		std::cout << '\n';
	}
	std::cout << '\n' << '\n';
}

```


# Shortest paths and matrix multiplication

O(V^3)
```

std::vector<std::vector<int>> EXTEND_SHORTEST_PATHS(std::vector<std::vector<int>>& L, std::vector<std::vector<int>>& W)
{
	const int n = L.size();


	std::vector<std::vector<int>> L_prime;
	L_prime.assign(n, std::vector<int>(n, INF));
	for(int i = 1; i < n; i++)
	{
		for (int j = 1; j < n; j++)
		{

			for (int k = 1; k < n; k++)
			{
				L_prime[i][j] = (L_prime[i][j] < L[i][k] + W[k][j] ?  L_prime[i][j] : L[i][k] + W[k][j]);
			}

		}
	}
	return L_prime;
}
```


총 O(V^4)
```

//nxn 1~n
std::vector<std::vector<int>>SLOW_ALL_PAIRS_SHORTEST_PATHS(std::vector<std::vector<int>>& W)
{
	const int n = W.size() - 1;

	std::vector<std::vector<std::vector<int>>> L;
	L.resize(n+1);
	for (int i = 0 ; i < n+1;i++)
	{
		L[i].resize(n+1);
		for (int j = 0; j < n + 1; j++)
		{
			L[i][j].resize(n + 1);
		}
	}
	L[1] = W;
	for (int m = 2; m < n; m++)
	{
		L[m] = EXTEND_SHORTEST_PATHS(L[m - 1], W);
	}
	return L[n-1];
}
```



총 O(V^3log(V))
```
std::vector<std::vector<int>>FASTER_ALL_PAIRS_SHORTEST_PATHS(std::vector<std::vector<int>>& W)
{
	const int n = W.size() - 1;

	std::vector<std::vector<std::vector<int>>> L;
	int a = 1;
	while (a < n)
	{
		a = a * 2;
	}


	L.resize(a+1);
	for (int i = 0; i <= a ; i++)
	{
		L[i].resize(n+1);
		for (int j = 0; j <= n ; j++)
		{
			L[i][j].resize(n + 1);
		}
	}
	L[1] = W;
	int m = 1;
	while(m < n -1)
	{
		L[2*m] = EXTEND_SHORTEST_PATHS(L[m], L[m]);
		m = m*2;
	}
	return  L[m];
}
```


