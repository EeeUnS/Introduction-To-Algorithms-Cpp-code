\section{소수 판별법}



1. 1부터 root(n)아래 자연수까지 모두 나눠본후 나눠지는 수가없을시에 그수는 소수입니다

2. 2부터시작해서 3부터 n까지 그전에 나온 소수들로 모두 한번씩 나눠봅니다 전에 나온 소수들로 안나눠질시 그 수는 소수입니다



이글의 연장선상인 얘기입니다.

하나의 값 n을 놓고 이값이 소수인지 아닌지 보려면 최소 root(n)가지 만큼 비교해 보아야 확정적으로 알수있습니다.

엄청난 크기의 소수를 구하기 위해서 root(n)만큼의 시간도 길다고 판단해
이보다 좀더 효율적임을 위해서 결국 정확도를 조금 포기하고 시간을얻는 방식이 나왔습니다.

첫번째로 n이 소수일때 무조건 성립하는 식이 하나가 있습니다. 그렇다고합시다.
n과 서로소인 a에 대해서 a^(n-1) 을 n으로 나눈 나머지는 무조건 1이 됩니다.(오일러정리 or 페르마의 소정리)
소수일때는 무조건 성립하니까 이를 판별 방식으로 쓰자는거죠


따라서 어떤 값 n에 대해서 a^(n-1) 을 n으로 나눈 나머지가 1인지만 판별해보면 됩니다.

이때는  a^(n-1)을 계산하기만하면됩니다 
적당한 a를 뽑고,
어떤값의 지수승을 구할때 평균적으로 log(n)번에 구하는 방법이 알려져있습니다. 따라서 이는 log(n)에 구할수가있습니다.

이때 나오는 오진은 소수가 아닌데 a^(n-1)을 n으로 나눈 나머지가 1이 되는 경우입니다.
이때 이 값을 카마이클 수(Carmichael number)라고 합니다 이 수의 특성도 재밌긴한데(사실 잘모름) 대충 넘어갑니다.

카마이클수를 차례대로 나타내면

561, 1105, 1729, 2465, 2821, 6601, 8911, 10585, 15841, 29341, 41041, 46657, 52633, 62745, 63973, 
굉장히 띄엄띄엄 있습니다 따라서 오진율이 낮습니다.


밀러라빈소수 판별법

이를 조금더 보완하기 위해서 검사를 더 촘촘히 하기로 합니다.

다음 증명된 사실을 가지고 합니다.

소수 n에 대해서 
x^2을 n으로 나눈 나머지가 1이 되는 x의 해는 무조건 +-1이다.(-1은 n-1과 같음.) 

따라서 이 나머지가 1이되는데 x가 +-1인지를 살펴 보면됩니다.

n-1 를  2^t*d (d는 홀수)로 나타냅니다.
a^d부터 a^(2^t*d)로 점점 제곱하면서 이 사이에 값이 1,n-1인데 그전의 값이 +-1이 아닌지 판별을 합니다.
예를 들어 카마이클 수는 561을 a = 2로 해서 구해보면
마지막에 a^(2^t*d)이 1이 되지만 제곱하기전의 값이 1이 아니라서 여기서 걸러지게 됩니다.


근데 이 판별이 결국 a에 따라 갈리게 됩니다.
a값이 n에 대해서 제곱했을때 1이 되는 근이 되어야 판별이 가능하죠 이는 
합성수 n에 대한 다음 판별 방식으로 탐지되는 근이 1~n-1사이에  최소 n/2가 존재합니다

확실한건 a를 1~n/2로 정하면 확실하게 나옵니다.


a를 촘촘하게 여러번 선택해서 판별하면 되는데 이러면 또 시간이 오래걸리죠

따라서 탐지율이 확률에 따라 다릅니다.