

텍스트 $T[1..n]$ 

패턴 $P[1..m]$

\section{The naive string-matching algorithm}
전처리 0 , 매칭시간 $O((n-m+1)m)$

가장간단하면서 일반적으로 생각할수있는 방법이다.
T[k]일때마다 T[k+m-1]까지 하나하나 P와 맞는지 확인하는것이다.

\begin{lstlisting}[syle = CStyle]
NAIVE-STRING-MATCHER (T,P)
    n = T.length
    m = P.length
    for s = 0 to n-m
        if(P[1..m] == T[s+1..s+m])
            print "Pattern occurs with shift s"
\end{lstlisting}



\section{The Rabin-Karp algorithm}
전처리 $\Theta(m)$
매칭시간 $O((n-m+1)m)$

수행시간을 개선하는 첫번째 아이디어는 문자를 숫자로 바꾸는것이다.
$111$과 $121$이란 문자열을 비교하려면 첫번째방법인 각 자리별로 3번 비교해야하지만 숫자로 비교하는건 한번만 비교하면된다.

따라서 문자열을 숫자로 바꾸기위한 전처리 시간이 든다.
전처리는 P패턴만을 $\Theta(m)$동안 바꾸고 문자열 T는 비교와 동시에 처리한다.


\begin{lstlisting}[syle = CStyle]
RABIN-KARP-MATCHER(T,P,d,q)
    n = T.length
    m = P.length
    h = d^{m-1} mod q
    p = 0
    t_0 = 0
    for( i = 1 to m)
        p = (dp+P[i])mod q
        t_0 = (dt_0 + T[i]) mod q
    for s = 0 to n-m
        if p == t_s
            if P[1..m] == T[s+1..s+m]
                print "Pattern occurs with shift s"
        if s < n - m
            t_{s+1} = (d(t_s - T[s+1]h) + T[s+m+1]) mod q
\end{lstlisting}


\section{String matching with finite automata}
전처리
$O(m|\sum|)$
매칭시간 $\Theta(n)$

\section{The Knuth-Morris-Pratt algorithm}
전처리
$O(m)$
매칭시간 $\Theta(n)$
